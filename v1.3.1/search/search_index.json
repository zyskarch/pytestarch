{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyTestArch","text":"<p>PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is  generally inspired by ArchUnit.</p>"},{"location":"#installation-guide","title":"Installation Guide","text":"<p>PyTestArch is available via PyPI and can be installed e.g. via pip: <code>pip install pytestarch</code>.</p>"},{"location":"#usage-guide","title":"Usage Guide","text":"<p>Three steps are required to test an architectural rule:</p> <p>1) Create an evaluable representation of the source code you want to test</p> <pre><code>from pytestarch.pytestarch import get_evaluable_architecture\n\nevaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\")\n</code></pre> <p>This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external  dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest, you could use a fixture for this evaluable object.</p> <p>2) Define an architectural rule</p> <pre><code>from pytestarch.query_language.base_language import Rule\n\nrule = Rule()\n        .modules_that()\n        .are_named(\"src.moduleB\")\n        .should_not()\n        .be_imported_by_modules_that()\n        .are_sub_modules_of(\"src.moduleA\"),\n</code></pre> <p>This rule represents the architectural requirements that a module named \"src.moduleB\" should not be imported by any module that is a submodule of \"src.moduleA\", excluding \"src.moduleA\" itself.</p> <p>3) Evaluate your code against this rule</p> <pre><code>rule.assert_applies(evaluable)\n</code></pre> <p>That's it!</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project uses semantic versioning and follows keep a changelog.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Internal module structure to improve coupling, cohesion.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Support for python3.8.</li> </ul>"},{"location":"changelog/#130-2022-11-28","title":"[1.3.0] -- 2022-11-28","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Reference to modules only by part of their names</li> <li>Aliases for plot labels</li> <li>Test generation from PUML component diagrams</li> </ul>"},{"location":"changelog/#121-2022-10-21","title":"[1.2.1] -- 2022-10-21","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Queries with \"except itself\" excluded too many modules from consideration</li> </ul>"},{"location":"changelog/#120-2022-10-08","title":"[1.2.0] -- 2022-10-08","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Line separator for rule violation messages</li> </ul>"},{"location":"changelog/#111-2022-10-04","title":"[1.1.1] -- 2022-10-04","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Line separator for rule violation messages</li> </ul>"},{"location":"changelog/#110-2022-10-02","title":"[1.1.0] -- 2022-10-02","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Rule objects can be passed in as a list</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>All violations not always returned</li> </ul>"},{"location":"changelog/#103-2022-09-28","title":"[1.0.3] -- 2022-09-28","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Simplified calculation of whether imports are within the project</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Excluded directories no longer searched for parseable files</li> </ul>"},{"location":"changelog/#102-2022-09-28","title":"[1.0.2] -- 2022-09-28","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>All internal modules filtered out if module and root path are not identical and are a sub module of the actual root module.</li> </ul>"},{"location":"changelog/#101-2022-09-27","title":"[1.0.1] -- 2022-09-27","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Module no longer considered if rule asked only for submodules of a given module</li> </ul>"},{"location":"changelog/#100-2022-09-27","title":"[1.0.0] -- 2022-09-27","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Rename entry point methods for clarity</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Reference to outdated code in documentation</li> </ul>"},{"location":"changelog/#010-2022-09-23","title":"[0.1.0] -- 2022-09-23","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>More detailed error message for violations of rules checking for absence of imports</li> <li>Versioning of documentation</li> </ul>"},{"location":"changelog/#010-alpha4-2022-09-23","title":"[0.1.0-alpha.4] -- 2022-09-23","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Documentation for release of PyTestArch</li> <li>More detailed project description</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Computation of dependencies between modules on graph</li> </ul>"},{"location":"changelog/#010-alpha3-2022-09-20","title":"[0.1.0-alpha.3] -- 2022-09-20","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Different construction of graph node names between OS</li> </ul>"},{"location":"changelog/#010-alpha1-2022-09-20","title":"[0.1.0-alpha.1] -- 2022-09-20","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Documentation</li> <li>library MVP</li> </ul>"},{"location":"details/","title":"Details","text":""},{"location":"details/#general-concept","title":"General Concept","text":"<p>PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about  module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the  NetworkX library.</p> <p>When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph.</p>"},{"location":"details/#simple-example","title":"Simple Example","text":""},{"location":"details/#parsing-all-files","title":"Parsing all files","text":"<p>Consider the following project structure:</p> <pre><code>my_project/\n    src/\n        main.py\n        util.py\n        util_test.py\n</code></pre> <p>Both <code>main.py</code> and <code>util_test.py</code> are importing a util function defined in <code>util.py</code>; no other imports exist.</p> <p>With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph:</p> <p></p> <p>Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains,  \"src.main\", \"src.util\", and \"src.util_test\".</p> <p>In addition, a module that imports another module has a directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\".</p>"},{"location":"details/#excluding-some-files","title":"Excluding some files","text":"<p>In the example above, the <code>util_test.py</code> file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude <code>util_test.py</code>, we could use:</p> <pre><code>from pytestarch.pytestarch import get_evaluable_architecture\n\nevaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", (\"*_test.py\"))\n</code></pre> <p>This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories.</p>"},{"location":"details/#more-complex-example","title":"More complex example","text":"<p>As a basis for describing the query language, let's consider a more complex example:</p> <pre><code>/test_project\n    /src\n       __init__.py\n       /A\n            __init__.py\n            fileA.py\n            /A1\n                __init__.py\n                fileA1.py\n                fileA1_b.py\n                /A11\n                    __init__.py\n                    fileA11.py\n            /A2\n                __init__.py\n                fileA2.py\n       /B\n            __init__.py\n            fileB.py\n            /B1\n                __init__.py\n                fileB1.py\n                fileB2.py\n       /C \n            __init__.py\n            fileC.py\n</code></pre> <p>With the following list of imports:</p> <ul> <li>fileA imports fileC</li> <li>fileA11 imports fileB1</li> <li>fileA2 imports fileC</li> <li>fileB imports fileA11</li> <li>fileB2 imports fileA11</li> <li>fileC imports the built-in os module</li> </ul> <p>This creates the following graph (excluding all <code>__init__.py</code>):</p> <p></p> <p>Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\".</p> <p>Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all.</p> <p>This has been achieved by setting the <code>exclude_external_libraries</code> flag in the <code>get_evaluable_architecture</code> function. All modules that  not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph.</p>"},{"location":"details/#query-language","title":"Query Language","text":""},{"location":"details/#general-structure","title":"General Structure","text":"<p>The query language that can be used to define architectural rules follows this structure: </p> <p>RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT</p> <p>The meaning of these structural markers is described in the table below.</p> Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except <p>The examples given in the table above combined form the rule <code>modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT)</code>.</p> <p>Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing  from the \"B\" module is \"fileA11\", which is a submodule of \"A\".</p>"},{"location":"details/#features","title":"Features","text":"<p>Currently, the following markers are supported by PyTestArch:</p>"},{"location":"details/#rule_subject","title":"RULE_SUBJECT","text":"<ul> <li>are_named(\"X\"): applies to module named \"X\" (and also to its submodules)</li> <li>are_submodules_of(\"Y\"): applies to submodules of module named \"Y\", but not \"Y\" itself</li> <li>have_name_containing(\"Z\"): applies to modules with names containing Z. The syntax is the same as for the file exclusion mechanism.</li> </ul>"},{"location":"details/#rule_object","title":"RULE_OBJECT","text":"<p>same as RULE_SUBJECT, with an additional</p> <p>anything: can only be used in combination with should_not()</p> <p>In order to reduce the number of possible API component combinations, this rule object has been combined with two verbs into: <code>import_anything()</code> and <code>be_imported_by_anything()</code>. </p> <p>In addition, RULE_OBJECTS can be passed in as a list. The rule is fulfilled if it applies to all rule objects. For example, the rule</p> <pre><code>modules_that()\n    .are_named(\"1\")\n    .should_only()\n    .be_imported_by_modules_that()\n    .are_named([\"2\", \"3\"])\n</code></pre> <p>is fulfilled, it the module \"1\" is not imported by any module other than \"2\" and \"3\", and if both \"2\" and \"3\" do import \"1\".</p>"},{"location":"details/#verb_marker_1","title":"VERB_MARKER_1","text":"<ul> <li>should()</li> <li>should_only()</li> <li>should_not()</li> </ul>"},{"location":"details/#import_type-verb_marker_2","title":"IMPORT_TYPE + VERB_MARKER_2","text":"<ul> <li>import_modules_that()</li> <li>import_modules_except_modules_that()</li> <li>be_imported_by_modules_that()</li> <li>be_imported_by_modules_except_modules_that()</li> </ul> <p>VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability.</p> <p>Markers from each category can be combined freely with all markers of all other categories. Example rules could be </p> <pre><code>modules_that()\n    .are_sub_modules_of(\"A\")\n    .should_only()\n    .be_imported_by_modules_that()\n    .are_sub_modules_of(\"B\")\n</code></pre> <p>(True in the above example)</p> <p>or </p> <pre><code>modules_that()\n    .are_named(\"C\")\n    .should_only()\n    .be_imported_by_modules_that()\n    .are_named(\"A2\")\n</code></pre> <p>(False, also imported by module \"A\")</p> <p>Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo-code for brevity):</p> Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1 <p>There are two aliases to make rules easier:</p> <ul> <li>'M1 should not import anything' is equivalent to: 'M1 should not import anything except itself' (e.g. imports between its submodules are allowed, but no other imports)</li> <li>'M1 should not be imported by anything' is equivalent to: 'M1 should not be imported by anything except itself' (dito)</li> </ul>"},{"location":"details/#generating-the-evaluable-architecture-representation","title":"Generating the evaluable architecture representation","text":"<p>When scanning and processing the requested modules, PyTestArch executes the following step: 1) Parse all files starting at the requested <code>module_path</code>. This only takes python source files into account that are not explicitly excluded.</p> <p>2) Convert the generated AST into custom dependency representations. In this step, it is ensured that all internal modules (either importing or imported) receive their fully  qualified name.</p> <p>3) Generate a list of all modules that were parsed. This list is used to differentiate between external and internal dependencies (external dependencies will not have been parsed).</p> <p>4) If not requested otherwise, external dependencies will be filtered out.</p> <p>5) If external dependencies should be included, they will be added to the list of modules.</p> <p>6) The dependency representations are converted to a graph structure.</p>"},{"location":"details/#visualizing-architecture","title":"Visualizing architecture","text":"<p>The graph structure can be plotted with <code>evaluable_architecture.visualize()</code> (requires matplotlib), which plots the dependency graph. By default, the nodes are labeled with their module name. If a module name is long  and/or a module has many submodules, the labels may crowd the plot. This can be  addressed by specifying (short) aliases for the module names by using the keyword argument  <code>aliases</code>. An alias will replace the module name in the label of the respective module and all its submodules unless the submodule also has an alias, in that case the submodule's alias takes priority.</p>"},{"location":"details/#alias-examples","title":"Alias Examples:","text":"<p>Consider an architecture with modules <code>long_root_name, long_root_name.submodule, long_root_name.submodule.sub_submodule, long_root_name.other_submodule</code> then the  resulting labels for a given aliases are:</p> aliases labels <code>{'long_root_name': 'r'}</code> <code>r, r.submodule, r.submodule.sub_submodule, r.other_submodule</code> <code>{'long_root_name': 'r', 'long_root_name.submodule': 'sub'}</code> <code>r, sub, sub.sub_submodule, r.other_submodule</code>"},{"location":"details/#testing-your-architecture-based-on-plantuml-component-diagrams","title":"Testing your architecture based on PlantUML component diagrams","text":""},{"location":"details/#general","title":"General","text":"<p>Instead of hand-crafting a number of rules, you can supply the path to a PlantUML component diagram via a <code>DiagramRule</code>. PyTestArch will then parse this file and generate rules based on the connections of nodes in this diagram. Connections between two nodes will be converted into 'should only' or 'should' import rules; the absence of a connection will be converted into 'should not' import rules. All rules are then evaluated against an Evaluable.</p> <p>Currently, parent-child relationships between modules are not supported. This means that for module X and its submodule Y, an edge between them in the diagram will be interpreted as an 'imports' relationship, not a 'submodule relationship'.</p> <p>There are two options for naming the components in your diagram:</p> <p>1) Use their fully qualified name, starting at the root module. For example, in the complex example above, this could be \"src.A.fileA\" instead of just \"fileA\"  2) Use only the name of the module itself, for example \"fileA\". Then you need to supply the prefix left out in the diagrams relative to your root module. In our example,     this would be \"src.A\". PyTestArch will then prefix all components in the diagram with this string. </p>"},{"location":"details/#supported-plantuml-language-features","title":"Supported PlantUML language features","text":"<p>Syntactical requirements for .puml files: * start of dependency definition needs to be tagged with @startuml * end of dependency definition needs to be tagged with @enduml * all text outside these tags is ignored * component names must be enclosed in square brackets * exception: if a component as been given an alias via <code>[module name] as alias</code>, then the alias should not be wrapped in square brackets * dependencies must be with either --&gt;, -&gt;, &lt;--, &lt;-, -text-&gt;, or &lt;-text-. The dependee is to be placed on the side of the arrow head, the dependor on the opposite side</p>"},{"location":"details/#additional-notes","title":"Additional Notes","text":""},{"location":"details/#root_path-vs-module_path-in-get_evaluable_architecture","title":"root_path vs. module_path in get_evaluable_architecture","text":"<p>The <code>root_path</code> should point towards the most top level module. In the example above, this would be <code>src</code> - not <code>test_project</code>, as <code>test_project</code> is not the top level code directory. The <code>module_path</code> is the module where the dependency scan will start. It has to be either identical to <code>root_path</code> or  a submodule of it.</p>"},{"location":"details/#module-names","title":"Module names","text":"<p>In all rules, modules have to be referred to by their fully qualified name, meaning relative to the <code>root_path</code> - not the <code>module_path</code>! This helps to distinguish between internal and external modules.</p>"},{"location":"references/diagram_extension/","title":"Diagram Extension","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension","title":"<code>diagram_extension</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule","title":"<code>diagram_rule</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule.DiagramRule","title":"<code>DiagramRule</code>","text":"<p>         Bases: <code>FileRule</code>, <code>BaseModuleSpecifier</code>, <code>RuleApplier</code></p> <p>Represents a set of architectural rules as defined in a diagram file. Reads the specified file, generates architectural rules, and returns an aggregated test result.</p> <p>By default, \"should only import\" rules will be generated for modules that the diagram shows as connected. \"Should not import\" rules will be generated for modules that are not connected in the diagram.</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule.DiagramRule.__init__","title":"<code>__init__(should_only_rule=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>should_only_rule</code> <code>bool</code> <p>if True, edges between components will be converted into 'should only import' rules.</p> <code>True</code>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter","title":"<code>dependency_to_rule_converter</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter.DependencyToRuleConverter","title":"<code>DependencyToRuleConverter</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter.DependencyToRuleConverter.convert","title":"<code>convert(dependencies)</code>","text":"<p>Converts a parsed dependency object to a list of RuleAppliers. All explicit dependencies in the given object are converted to should (only) rules. All missing, but possible dependencies between the given modules are converted to 'should not' rules.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>ParsedDependencies</code> <p>parsed modules and dependencies between modules</p> required <p>Returns:</p> Type Description <code>List[RuleApplier]</code> <p>list of RuleAppliers that can be applied to an evaluable</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser","title":"<code>diagram_parser</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser.PumlParser","title":"<code>PumlParser</code>","text":"<p>         Bases: <code>DiagramParser</code></p> <p>Parses .puml files to a dependencies object that can be used to generate architecture rules.</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser.PumlParser.parse","title":"<code>parse(file_path)</code>","text":"<p>Syntactical requirements for .puml files:     * start of dependency definition needs to be tagged with @startuml     * end of dependency definition needs to be tagged with @enduml     * all text outside these tags is ignored     * component names must be enclosed in square brackets     * exception: if a component as been given an alias via <code>[module name] as alias</code>, then the alias should not be         wrapped in square brackets     * dependencies must be with either --&gt;, -&gt;, &lt;--, &lt;-, -text-&gt;, or &lt;-text-. The dependee is to be placed         on the side of the arrow head, the dependor on the opposite side</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>.puml file to parse</p> required <p>Returns:</p> Type Description <code>ParsedDependencies</code> <p>dependencies object that can be used to generate architecture rules.</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.parsed_dependencies","title":"<code>parsed_dependencies</code>","text":""},{"location":"references/eval_structure/","title":"Evaluation Structures","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure","title":"<code>eval_structure</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture","title":"<code>evaluable_architecture</code>","text":"<p>Abstract types to specify the interface of evaluable objects.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture","title":"<code>EvaluableArchitecture</code>","text":"<p>         Bases: <code>Protocol</code></p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_dependencies_from_dependents_to_modules_other_than_dependent_upons","title":"<code>any_dependencies_from_dependents_to_modules_other_than_dependent_upons(dependents, dependent_upons)</code>","text":"<p>Returns list of depending modules per dependent module if the dependent module has any dependency to a module other than the dependent_upon modules or any of their submodules.</p> <p>If a dependent module is defined via a parent module, this parent module is not taken into account. If a dependent upon module is defined via a parent module, this parent module counts as an 'other' dependency.     Reason behind this: If we want to know whether there are any dependencies from X to any non-Y modules,     Y's parent is such a module, as this parent module can and usually will also contain other modules than Y.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module</p> required <code>dependent_upon</code> <p>Module</p> required <p>Returns:</p> Type Description <code>UnexpectedDependenciesByBaseModule</code> <p>All modules other than dependent_upon on which dependent module as any dependency per dependent module</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_other_dependencies_on_dependent_upons_than_from_dependents","title":"<code>any_other_dependencies_on_dependent_upons_than_from_dependents(dependents, dependent_upons)</code>","text":"<p>Returns list of depending modules per dependent_upon module if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. If the dependent module is defined via a parent module, this parent module is taken into account. This means that if the dependent module's parent module has a dependency to the dependent upon module, this will be contained in the returned list. If the dependent upon module is defined via a parent module, this parent module is not taken into account.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module</p> required <code>dependent_upon</code> <p>Module</p> required <p>Returns:</p> Type Description <code>UnexpectedDependenciesByBaseModule</code> <p>All modules other than dependent that have any dependency on the dependent upon module per dependent_upon module</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.get_dependencies","title":"<code>get_dependencies(dependents, dependent_upons)</code>","text":"<p>Returns tuple of importer and importee per dependent and depending module if the dependent module is indeed depending on the dependent_upon module. In short: find all dependencies between dependent and dependent_upons.</p> <p>Submodules of dependent and dependent upon are taken into account. If X.A depends on Y, then X also depends on Y, as X.A is part of X. If X depends on Y.Z, then it also depends on Y.</p> <p>If one or both of the modules are defined by their parent module, this parent module is excluded from possible matches.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module(s)</p> required <code>dependent_upon</code> <p>Module(s)</p> required <p>Returns:</p> Type Description <code>DependenciesByBaseModules</code> <p>Importer and importee per pair of dependent and dependent_upon module if there are any</p> <code>DependenciesByBaseModules</code> <p>that are sub modules of dependent and dependent_upon respectively.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.visualize","title":"<code>visualize(**kwargs)</code>","text":"<p>Uses matplotlib to draw the underlying dependency structure.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout).</p> <code>{}</code>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.Module","title":"<code>Module</code>  <code>dataclass</code>","text":"<p>Represents a python module. The module can either be identified by its name or by the name of a parent module.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>full name of the module</p> <code>parent_module</code> <code>Optional[str]</code> <p>full name of the parent module</p> <code>partial_match</code> <code>bool</code> <p>if True, the name may only represent a single part of the actual module name</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_structures","title":"<code>evaluable_structures</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_graph","title":"<code>evaluable_graph</code>","text":"<p>Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_graph.EvaluableArchitectureGraph","title":"<code>EvaluableArchitectureGraph</code>","text":"<p>         Bases: <code>EvaluableArchitecture</code></p> <p>Abstract implementation of an evaluable object that is based on a graph structure.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph","title":"<code>networkxgraph</code>","text":"<p>Encapsulation of networkx graph functionality.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph","title":"<code>NetworkxGraph</code>","text":"<p>         Bases: <code>AbstractGraph</code></p> <p>Constructs eval_structure from list of imports.</p> <p>Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy.</p> <p>E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')]</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.__init__","title":"<code>__init__(all_modules, imports, level_limit=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>all_modules</code> <code>List[Node]</code> <p>list of all nodes in the graph, which can be connected by imports.</p> required <code>imports</code> <code>List[Import]</code> <p>all dependencies between the graph's nodes.</p> required <code>level_limit</code> <code>Optional[int]</code> <p>if not None, specifies the depth of the graph</p> <code>None</code>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.direct_predecessor_nodes","title":"<code>direct_predecessor_nodes(node)</code>","text":"<p>Returns all nodes that have a directed edge towards the given node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node for which to retrieve predecessor nodes</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>all predecessor nodes</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.direct_successor_nodes","title":"<code>direct_successor_nodes(node)</code>","text":"<p>Returns all nodes that the given node has a directed edge towards.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node for which to retrieve successor nodes</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>all successor nodes</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.draw","title":"<code>draw(**kwargs)</code>","text":"<p>Creates a matplotlib plot representing the graph.</p> <p>Other Parameters:</p> Name Type Description <code>spacing</code> <code>float</code> <p>optimal distance between nodes</p> <code>aliases</code> <code>Dict[str, str]</code> <p>module name aliases for plot labels. Keys are module names and values the aliases. If no alias is specified the module name is used a node label. If a module name has an alias, the module name is replaced by the alias for the module and all its submodules, e.g. for modules a, a.b, a.c, a.c.d and aliases == {'a', 'A'}, the plot labels for these modules will be A, A.b, A.c, A.c.d. If a submodule also has an alias, the alias for the submodule takes priority, e.g. with the same modules as above and aliases == {'a': 'A', 'a.c': 'C'} the plot labels will be A, A.b, C, C.d.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.parent_child_relationship","title":"<code>parent_child_relationship(supposed_parent_node, supposed_child_node)</code>","text":"<p>Returns True if the given nodes are marked as a parent-child hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>supposed_parent_node</code> <code>Node</code> required <code>supposed_child_node</code> <code>Node</code> required <p>Returns:</p> Type Description <code>bool</code> <p>True if supposed parent is actually parent of supposed child node</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types","title":"<code>types</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import","title":"<code>Import</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importee","title":"<code>importee()</code>  <code>abstractmethod</code>","text":"<p>Returns name of a module that is being imported.</p> <p>Returns:</p> Type Description <code>str</code> <p>module name</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importee_parent_modules","title":"<code>importee_parent_modules()</code>  <code>abstractmethod</code>","text":"<p>Returns names of all parent modules of the imported module.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of module names</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importer","title":"<code>importer()</code>","text":"<p>Returns name of the module that imports something.</p> <p>Returns:</p> Type Description <code>str</code> <p>module name</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importer_parent_modules","title":"<code>importer_parent_modules()</code>","text":"<p>Returns names of all parent modules of the importing module.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of module names</p>"},{"location":"references/eval_structure_generation/","title":"Evaluation Structure Generation","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation","title":"<code>eval_structure_generation</code>","text":"<p>Contains all functionality relating to loading and parsing python source code and creating custom import objects representing the dependencies between the modules.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import","title":"<code>file_import</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter","title":"<code>file_filter</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter.FileFilter","title":"<code>FileFilter</code>","text":"<p>Uses a pseudo-regex pattern to determine whether a file or directory should be excluded.</p> <p>Allowed patterns are: - A: file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A: file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A'</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter.FileFilter.is_excluded","title":"<code>is_excluded(path)</code>","text":"<p>Returns True if the path matches one of the pre-configured exclusion patterns.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter","title":"<code>import_filter</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter","title":"<code>ImportFilter</code>","text":"<p>Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter.__init__","title":"<code>__init__(exclude_external_libraries, root_module_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>exclude_external_libraries</code> <code>bool</code> <p>If True, external modules will be filtered out, otherwise this class implements a no-op.</p> required <code>root_module_name</code> <code>str</code> <p>name of the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal.</p> required"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter.filter","title":"<code>filter(imports)</code>","text":"<p>According to the configuration, imports will be filtered.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>List[Import]</code> <p>list of imports to be filtered</p> required <p>Returns:</p> Type Description <code>List[Import]</code> <p>filtered list of imports</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types","title":"<code>import_types</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.AbsoluteImport","title":"<code>AbsoluteImport</code>","text":"<p>         Bases: <code>Import</code></p> <p>Represents an absolute import.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.NamedModule","title":"<code>NamedModule</code>  <code>dataclass</code>","text":"<p>Contains an ast module with its name.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>ast.Module</code> <p>ast module object</p> <code>name</code> <code>str</code> <p>module name</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.RelativeImport","title":"<code>RelativeImport</code>","text":"<p>         Bases: <code>Import</code></p> <p>Represents a relative import.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator","title":"<code>importee_module_calculator</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator.ImporteeModuleCalculator","title":"<code>ImporteeModuleCalculator</code>","text":"<p>Adds all parent modules of imported modules if they are not yet part of the modules list.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator.ImporteeModuleCalculator.calculate_importee_modules","title":"<code>calculate_importee_modules(imports, all_modules)</code>","text":"<p>For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>List[Import]</code> required <code>all_modules</code> <code>List[str]</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>all modules extended by parent modules of imported modules</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser","title":"<code>parser</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser.Parser","title":"<code>Parser</code>","text":"<p>Parses all files that match given criteria starting at a source path.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser.Parser.parse","title":"<code>parse(path)</code>","text":"<p>Reads all python files in the given path and returns list of ast modules with names.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>either to a file or to a directory</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[NamedModule]]</code> <p>list of python modules, one per python file</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.graph_generation","title":"<code>graph_generation</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.graph_generation.graph_generator","title":"<code>graph_generator</code>","text":""},{"location":"references/general/","title":"General","text":""},{"location":"references/general/#src.pytestarch.pytestarch","title":"<code>pytestarch</code>","text":"<p>The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules.</p>"},{"location":"references/general/#src.pytestarch.pytestarch.get_evaluable_architecture","title":"<code>get_evaluable_architecture(root_path, module_path, exclusions=DEFAULT_EXCLUSIONS, exclude_external_libraries=True, level_limit=None)</code>","text":"<p>Constructs an evaluable object based on the given module.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>root directory of the source code. Should not be set to a submodule of the top level module.</p> required <code>module_path</code> <code>str</code> <p>path of module to generate the evaluable for. Must be a submodule of the root_path module.</p> required <code>exclusions</code> <code>Tuple[str, ...]</code> <p>pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py</p> <code>DEFAULT_EXCLUSIONS</code> <code>exclude_external_libraries</code> <code>bool</code> <p>if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis.</p> <code>True</code> <code>level_limit</code> <code>Optional[int]</code> <p>if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit.</p> <code>None</code>"},{"location":"references/general/#src.pytestarch.pytestarch.get_evaluable_architecture_for_module_objects","title":"<code>get_evaluable_architecture_for_module_objects(root_module, module, exclusions=DEFAULT_EXCLUSIONS, exclude_external_libraries=True, level_limit=None)</code>","text":"<p>Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.</p>"},{"location":"references/query_language/","title":"Query Language","text":""},{"location":"references/query_language/#src.pytestarch.query_language","title":"<code>query_language</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.base_language","title":"<code>base_language</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier","title":"<code>BaseModuleSpecifier</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier.base_module_included_in_module_names","title":"<code>base_module_included_in_module_names()</code>  <code>abstractmethod</code>","text":"<p>If the diagram contains fully qualified module names.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier.with_base_module","title":"<code>with_base_module(name_relative_to_root)</code>  <code>abstractmethod</code>","text":"<p>Sets the name of the base module that was turned into an Evaluable. This enables the user to not having to include the entire name relative to the root module in the diagram. Example: root module is named 'src' Base module: my_project diagram generated for modules in src.my_project.components:     src.my_project.components.A, src.my_project.components.B     -&gt; components are named 'A', 'B' in diagram name_relative_to_root: src.my_project.components</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BehaviorSpecification","title":"<code>BehaviorSpecification</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Offers functionality to specify whether dependencies are expected or not.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.DependencySpecification","title":"<code>DependencySpecification</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Offers functionality to specify which kind of dependencies are expected.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.FileRule","title":"<code>FileRule</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.FileRule.from_file","title":"<code>from_file(file_path)</code>  <code>abstractmethod</code>","text":"<p>Set the path to the file containing the rules that should be applied to the evaluable.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification","title":"<code>ModuleSpecification</code>","text":"<p>         Bases: <code>Generic[ModuleSpecificationSuccessor]</code>, <code>ABC</code></p> <p>Offers functionality to specify detail information about Rule Subjects or Objects.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleApplier","title":"<code>RuleApplier</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleApplier.assert_applies","title":"<code>assert_applies(evaluable)</code>  <code>abstractmethod</code>","text":"<p>Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> <p>module dependency structure to compare the rule against</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the rule does not apply to the evaluable object</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleBase","title":"<code>RuleBase</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Entry point to each architectural rule.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.rule","title":"<code>rule</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.rule.Rule","title":"<code>Rule</code>","text":"<p>         Bases: <code>DependencySpecification</code>, <code>RuleBase</code>, <code>BehaviorSpecification</code>, <code>RuleObject</code>, <code>RuleSubject</code>, <code>RuleApplier</code></p> <p>Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2</p>"},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier","title":"<code>multiple_rule_applier</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier.MultipleRuleApplier","title":"<code>MultipleRuleApplier</code>","text":"<p>         Bases: <code>RuleApplier</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier.MultipleRuleApplier.assert_applies","title":"<code>assert_applies(evaluable)</code>","text":"<p>Checks a number of rules against the given evaluable and returns an aggregated error message if at least one tests fails.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> required"},{"location":"references/rule_assessment/","title":"Rule Assessment","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment","title":"<code>rule_assessment</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message","title":"<code>error_message</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator","title":"<code>message_generator</code>","text":"<p>Converts a RuleViolations object into a human-readable format.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator","title":"<code>RuleViolationMessageGenerator</code>","text":"<p>Generates a message for each violated rule.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator.__init__","title":"<code>__init__(original_rule_subject, original_rule_objects, import_rule)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>original_rule_subject</code> <code>Module</code> <p>module as originally specified</p> required <code>original_rule_objects</code> <code>List[Module]</code> <p>modules as originally specified</p> required <code>import_rule</code> <code>bool</code> <p>True if the underlying rule is a \"import\" instead of an \"is imported\" rule</p> required"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator.create_rule_violation_message","title":"<code>create_rule_violation_message(rule_violations)</code>","text":"<p>Create a message about all rule violations.</p> <p>Parameters:</p> Name Type Description Default <code>rule_violations</code> <code>RuleViolations</code> <p>to convert to human-readable format</p> required <p>Returns:</p> Type Description <code>str</code> <p>message containing all individual rule violation messages</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator.create_rule_violation_messages","title":"<code>create_rule_violation_messages(rule_violations)</code>","text":"<p>Create a message about each rule violation.</p> <p>Parameters:</p> Name Type Description Default <code>rule_violations</code> <code>RuleViolations</code> <p>to convert to human-readable format</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>set of messages, each representing a rule violation</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check","title":"<code>rule_check</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher","title":"<code>rule_matcher</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.RuleMatcher","title":"<code>RuleMatcher</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Checks whether given modules fulfill the module and behavior requirements that have been specified for them.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.RuleMatcher.match","title":"<code>match(evaluable)</code>  <code>abstractmethod</code>","text":"<p>Checks whether an expected behavior is exhibited by the EvaluableArchitecture. If there are any rule violations, will raise an error detailing the violations.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> <p>object to check</p> required"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_violations","title":"<code>rule_violations</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement","title":"<code>behavior_requirement</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement","title":"<code>BehaviorRequirement</code>","text":"<p>Stores information about which import behavior the checked module is supposed to exhibit.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.lax_dependency_not_allowed","title":"<code>lax_dependency_not_allowed: bool</code>  <code>property</code>","text":"<p>Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.lax_dependency_required","title":"<code>lax_dependency_required: bool</code>  <code>property</code>","text":"<p>Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.strict_dependency_not_allowed","title":"<code>strict_dependency_not_allowed: bool</code>  <code>property</code>","text":"<p>Returns True if a dependency between two specific modules is not allowed.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.strict_dependency_required","title":"<code>strict_dependency_required: bool</code>  <code>property</code>","text":"<p>Returns True if a dependency between two specific modules is required.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.generate_rule_violation","title":"<code>generate_rule_violation(strict_dependencies, lax_dependencies)</code>","text":"<p>Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them.</p> <p>Parameters:</p> Name Type Description Default <code>strict_dependencies</code> <code>Optional[DependenciesByBaseModules]</code> <p>dependency between the two specified modules found, grouped by requested modules</p> required <code>lax_dependencies</code> <code>Optional[UnexpectedDependenciesByBaseModule]</code> <p>other dependencies found beside the two specified modules</p> required <p>Returns:</p> Type Description <code>RuleViolations</code> <p>overview of all rule violations</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.module_requirement","title":"<code>module_requirement</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.module_requirement.ModuleRequirement","title":"<code>ModuleRequirement</code>","text":"<p>Stores information about which module is supposed to be checked against which module.</p>"}]}