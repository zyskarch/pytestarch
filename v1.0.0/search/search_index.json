{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyTestArch PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is generally inspired by ArchUnit . Installation Guide PyTestArch is available via PyPI and can be installed e.g. via pip: pip install pytestarch . Usage Guide Three steps are required to test an architectural rule: 1) Create an evaluable representation of the source code you want to test from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\") This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest , you could use a fixture for this evaluable object. 2) Define an architectural rule from pytestarch.query_language.base_language import Rule rule = Rule() .modules_that() .are_named(\"src.moduleB\") .should_not() .be_imported_by_modules_that() .are_sub_modules_of(\"src.moduleA\"), This rule represents the architectural requirements that a module named \"src.moduleB\" should not be imported by any module that is a submodule of \"src.moduleA\", including \"src.moduleA\" itself. 3) Evaluate your code against this rule rule.assert_applies(evaluable) That's it!","title":"Welcome to PyTestArch"},{"location":"#welcome-to-pytestarch","text":"PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is generally inspired by ArchUnit .","title":"Welcome to PyTestArch"},{"location":"#installation-guide","text":"PyTestArch is available via PyPI and can be installed e.g. via pip: pip install pytestarch .","title":"Installation Guide"},{"location":"#usage-guide","text":"Three steps are required to test an architectural rule: 1) Create an evaluable representation of the source code you want to test from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\") This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest , you could use a fixture for this evaluable object. 2) Define an architectural rule from pytestarch.query_language.base_language import Rule rule = Rule() .modules_that() .are_named(\"src.moduleB\") .should_not() .be_imported_by_modules_that() .are_sub_modules_of(\"src.moduleA\"), This rule represents the architectural requirements that a module named \"src.moduleB\" should not be imported by any module that is a submodule of \"src.moduleA\", including \"src.moduleA\" itself. 3) Evaluate your code against this rule rule.assert_applies(evaluable) That's it!","title":"Usage Guide"},{"location":"changelog/","text":"Changelog This project uses semantic versioning and follows keep a changelog . [Unreleased] [1.0.0] -- 2022-09-27 Changed Rename entry point methods for clarity Fixed Reference to outdated code in documentation [0.1.0] -- 2022-09-23 Added More detailed error message for violations of rules checking for absence of imports Versioning of documentation [0.1.0-alpha.4] -- 2022-09-23 Added Documentation for release of PyTestArch More detailed project description Changed Computation of dependencies between modules on graph [0.1.0-alpha.3] -- 2022-09-20 Fixed Different construction of graph node names between OS [0.1.0-alpha.1] -- 2022-09-20 Added Documentation library MVP","title":"Changelog"},{"location":"changelog/#changelog","text":"This project uses semantic versioning and follows keep a changelog .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#100-2022-09-27","text":"","title":"[1.0.0] -- 2022-09-27"},{"location":"changelog/#changed","text":"Rename entry point methods for clarity","title":"Changed"},{"location":"changelog/#fixed","text":"Reference to outdated code in documentation","title":"Fixed"},{"location":"changelog/#010-2022-09-23","text":"","title":"[0.1.0] -- 2022-09-23"},{"location":"changelog/#added","text":"More detailed error message for violations of rules checking for absence of imports Versioning of documentation","title":"Added"},{"location":"changelog/#010-alpha4-2022-09-23","text":"","title":"[0.1.0-alpha.4] -- 2022-09-23"},{"location":"changelog/#added_1","text":"Documentation for release of PyTestArch More detailed project description","title":"Added"},{"location":"changelog/#changed_1","text":"Computation of dependencies between modules on graph","title":"Changed"},{"location":"changelog/#010-alpha3-2022-09-20","text":"","title":"[0.1.0-alpha.3] -- 2022-09-20"},{"location":"changelog/#fixed_1","text":"Different construction of graph node names between OS","title":"Fixed"},{"location":"changelog/#010-alpha1-2022-09-20","text":"","title":"[0.1.0-alpha.1] -- 2022-09-20"},{"location":"changelog/#added_2","text":"Documentation library MVP","title":"Added"},{"location":"details/","text":"Details General Concept PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the NetworkX library. When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph. Simple Example Parsing all files Consider the following project structure: my_project/ src/ main.py util.py util_test.py Both main.py and util_test.py are importing a util function defined in util.py ; no other imports exist. With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph: Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains, \"src.main\", \"src.util\", and \"src.util_test\". In addition, a module that imports another module has an directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\". Excluding some files In the example above, the util_test.py file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude util_test.py , we could use: from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", (\"*_test.py\")) This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories. More complex example As a basis for describing the query language, let's consider a more complex example: /test_project /src __init__.py /A __init__.py fileA.py /A1 __init__.py fileA1.py fileA1_b.py /A11 __init__.py fileA11.py /A2 __init__.py fileA2.py /B __init__.py fileB.py /B1 __init__.py fileB1.py fileB2.py /C __init__.py fileC.py With the following list of imports: fileA imports fileC fileA11 imports fileB1 fileA2 imports fileC fileB imports fileA11 fileB2 imports fileA11 fileC imports the built-in os module This creates the following graph (excluding all __init__.py ): Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\". Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all. This has been achieved by setting the exclude_external_libraries flag in the get_evaluable_architecture function. All modules that not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph. Query Language General Structure The query language that can be used to define architectural rules follows this structure: RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT The meaning of these structural markers is described in the table below. Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except The examples given in the table above combined form the rule modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT) . Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing from the \"B\" module is \"fileA11\", which is a submodule of \"A\". Features Currently, the following markers are supported by PyTestArch: RULE_SUBJECT are_named(\"X\"): applies to module named \"X\" are_submodules_of(\"Y\"): applies to submodules of module named \"Y\" RULE_OBJECT same as RULE_SUBJECT VERB_MARKER_1 should() should_only() should_not() IMPORT_TYPE + VERB_MARKER_2 import_modules_that() import_modules_except_modules_that() be_imported_by_modules_that() be_imported_by_modules_except_modules_that() VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability. Markers from each category can be combined freely with all markers of all other categories. Example rules could be modules_that() .are_sub_modules_of(\"A\") .should_only() .be_imported_by_modules_that() .are_sub_modules_of(\"B\") (True in the above example). or modules_that() .are_named(\"C\") .should_only() .be_imported_by_modules_that() .are_named(\"A2\") (False, also imported by module \"A\"). Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo code for brevity): Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1","title":"Details"},{"location":"details/#details","text":"","title":"Details"},{"location":"details/#general-concept","text":"PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the NetworkX library. When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph.","title":"General Concept"},{"location":"details/#simple-example","text":"","title":"Simple Example"},{"location":"details/#parsing-all-files","text":"Consider the following project structure: my_project/ src/ main.py util.py util_test.py Both main.py and util_test.py are importing a util function defined in util.py ; no other imports exist. With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph: Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains, \"src.main\", \"src.util\", and \"src.util_test\". In addition, a module that imports another module has an directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\".","title":"Parsing all files"},{"location":"details/#excluding-some-files","text":"In the example above, the util_test.py file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude util_test.py , we could use: from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", (\"*_test.py\")) This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories.","title":"Excluding some files"},{"location":"details/#more-complex-example","text":"As a basis for describing the query language, let's consider a more complex example: /test_project /src __init__.py /A __init__.py fileA.py /A1 __init__.py fileA1.py fileA1_b.py /A11 __init__.py fileA11.py /A2 __init__.py fileA2.py /B __init__.py fileB.py /B1 __init__.py fileB1.py fileB2.py /C __init__.py fileC.py With the following list of imports: fileA imports fileC fileA11 imports fileB1 fileA2 imports fileC fileB imports fileA11 fileB2 imports fileA11 fileC imports the built-in os module This creates the following graph (excluding all __init__.py ): Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\". Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all. This has been achieved by setting the exclude_external_libraries flag in the get_evaluable_architecture function. All modules that not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph.","title":"More complex example"},{"location":"details/#query-language","text":"","title":"Query Language"},{"location":"details/#general-structure","text":"The query language that can be used to define architectural rules follows this structure: RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT The meaning of these structural markers is described in the table below. Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except The examples given in the table above combined form the rule modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT) . Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing from the \"B\" module is \"fileA11\", which is a submodule of \"A\".","title":"General Structure"},{"location":"details/#features","text":"Currently, the following markers are supported by PyTestArch:","title":"Features"},{"location":"details/#rule_subject","text":"are_named(\"X\"): applies to module named \"X\" are_submodules_of(\"Y\"): applies to submodules of module named \"Y\"","title":"RULE_SUBJECT"},{"location":"details/#rule_object","text":"same as RULE_SUBJECT","title":"RULE_OBJECT"},{"location":"details/#verb_marker_1","text":"should() should_only() should_not()","title":"VERB_MARKER_1"},{"location":"details/#import_type-verb_marker_2","text":"import_modules_that() import_modules_except_modules_that() be_imported_by_modules_that() be_imported_by_modules_except_modules_that() VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability. Markers from each category can be combined freely with all markers of all other categories. Example rules could be modules_that() .are_sub_modules_of(\"A\") .should_only() .be_imported_by_modules_that() .are_sub_modules_of(\"B\") (True in the above example). or modules_that() .are_named(\"C\") .should_only() .be_imported_by_modules_that() .are_named(\"A2\") (False, also imported by module \"A\"). Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo code for brevity): Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1","title":"IMPORT_TYPE + VERB_MARKER_2"},{"location":"eval_structure/","text":"Evaluation eval_structure This model contains abstract types as well as their implementations to represent the imported dependencies in a queryable structure, such as graphs. eval_structure_types Abstract types to specify the interface of evaluable objects. EvaluableArchitecture Bases: Protocol any_dependency_to_module_other_than ( dependent , dependent_upon ) Returns True if the dependent module has any dependency to a module other than the dependent_upon module or any of its submodules. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description List [ Module ] All modules other than dependent_upon on which dependent module as any dependency any_other_dependency_to_module_than ( dependent , dependent_upon ) Returns True if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description List [ Module ] All modules other than dependent that have any dependency on the dependent upon module is_dependent ( dependent , dependent_upon ) Returns True if the dependent module is indeed depending on the dependent_upon module. Submodules of dependent towards are taken into account, but submodules of dependent_upon are not. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description Optional [ Tuple [ str , str ]] Importer and importee if there are any that are sub modules of dependent and dependent_upon respectively. visualize ( ** kwargs ) Uses matplotlib to draw the underlying dependency structure. Parameters: Name Type Description Default **kwargs Any Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout). {} Module dataclass Represents a python module. The module can either be identified by its name or by the name of a parent module. Attributes: Name Type Description name Optional [ str ] full name of the module parent_module Optional [ Node ] full name of the parent module evaluable_graph Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern. EvaluableArchitectureGraph Bases: EvaluableArchitecture Abstract implementation of an evaluable object that is based on a graph structure. graph Encapsulation of networkx graph functionality. Graph Constructs eval_structure from list of imports. Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy. E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')] __init__ ( all_modules , imports , level_limit = None ) Parameters: Name Type Description Default all_modules List [ Node ] list of all nodes in the graph, which can be connected by imports. required imports List [ Import ] all dependencies between the graph's nodes. required level_limit Optional [ int ] if not None, specifies the depth of the graph None direct_predecessor_nodes ( node ) Returns all nodes that have a directed edge towards the given node. Parameters: Name Type Description Default node Node node for which to retrieve predecessor nodes required Returns: Type Description List [ Node ] all predecessor nodes direct_successor_nodes ( node ) Returns all nodes that the given node has a directed edge towards. Parameters: Name Type Description Default node Node node for which to retrieve successor nodes required Returns: Type Description List [ Node ] all successor nodes draw ( ** kwargs ) Creates a matplotlib plot representing the graph. parent_child_relationship ( supposed_parent_node , supposed_child_node ) Returns True if the given nodes are marked as a parent-child hierarchy. Parameters: Name Type Description Default supposed_parent_node Node required supposed_child_node Node required Returns: Type Description bool True if supposed parent is actually parent of supposed child node","title":"Evaluation"},{"location":"eval_structure/#evaluation","text":"","title":"Evaluation"},{"location":"eval_structure/#src.pytestarch.eval_structure","text":"This model contains abstract types as well as their implementations to represent the imported dependencies in a queryable structure, such as graphs.","title":"eval_structure"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types","text":"Abstract types to specify the interface of evaluable objects.","title":"eval_structure_types"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.EvaluableArchitecture","text":"Bases: Protocol","title":"EvaluableArchitecture"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.EvaluableArchitecture.any_dependency_to_module_other_than","text":"Returns True if the dependent module has any dependency to a module other than the dependent_upon module or any of its submodules. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description List [ Module ] All modules other than dependent_upon on which dependent module as any dependency","title":"any_dependency_to_module_other_than()"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.EvaluableArchitecture.any_other_dependency_to_module_than","text":"Returns True if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description List [ Module ] All modules other than dependent that have any dependency on the dependent upon module","title":"any_other_dependency_to_module_than()"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.EvaluableArchitecture.is_dependent","text":"Returns True if the dependent module is indeed depending on the dependent_upon module. Submodules of dependent towards are taken into account, but submodules of dependent_upon are not. Parameters: Name Type Description Default dependent Module Module required dependent_upon Module Module required Returns: Type Description Optional [ Tuple [ str , str ]] Importer and importee if there are any that are sub modules of dependent and dependent_upon respectively.","title":"is_dependent()"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.EvaluableArchitecture.visualize","text":"Uses matplotlib to draw the underlying dependency structure. Parameters: Name Type Description Default **kwargs Any Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout). {}","title":"visualize()"},{"location":"eval_structure/#src.pytestarch.eval_structure.eval_structure_types.Module","text":"Represents a python module. The module can either be identified by its name or by the name of a parent module. Attributes: Name Type Description name Optional [ str ] full name of the module parent_module Optional [ Node ] full name of the parent module","title":"Module"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_graph","text":"Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern.","title":"evaluable_graph"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_graph.EvaluableArchitectureGraph","text":"Bases: EvaluableArchitecture Abstract implementation of an evaluable object that is based on a graph structure.","title":"EvaluableArchitectureGraph"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph","text":"Encapsulation of networkx graph functionality.","title":"graph"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph","text":"Constructs eval_structure from list of imports. Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy. E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')]","title":"Graph"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph.__init__","text":"Parameters: Name Type Description Default all_modules List [ Node ] list of all nodes in the graph, which can be connected by imports. required imports List [ Import ] all dependencies between the graph's nodes. required level_limit Optional [ int ] if not None, specifies the depth of the graph None","title":"__init__()"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph.direct_predecessor_nodes","text":"Returns all nodes that have a directed edge towards the given node. Parameters: Name Type Description Default node Node node for which to retrieve predecessor nodes required Returns: Type Description List [ Node ] all predecessor nodes","title":"direct_predecessor_nodes()"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph.direct_successor_nodes","text":"Returns all nodes that the given node has a directed edge towards. Parameters: Name Type Description Default node Node node for which to retrieve successor nodes required Returns: Type Description List [ Node ] all successor nodes","title":"direct_successor_nodes()"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph.draw","text":"Creates a matplotlib plot representing the graph.","title":"draw()"},{"location":"eval_structure/#src.pytestarch.eval_structure.graph.Graph.parent_child_relationship","text":"Returns True if the given nodes are marked as a parent-child hierarchy. Parameters: Name Type Description Default supposed_parent_node Node required supposed_child_node Node required Returns: Type Description bool True if supposed parent is actually parent of supposed child node","title":"parent_child_relationship()"},{"location":"general/","text":"General pytestarch The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules. get_evaluable_architecture ( root_path , module_path , exclusions = DEFAULT_EXCLUSIONS , exclude_external_libraries = True , level_limit = None ) Constructs an evaluable object based on the given module. Parameters: Name Type Description Default root_path str root directory of the source code required module_path str path of module to generate the evaluable for. Must be a submodule of the root_path module. required exclusions Tuple [ str , ...] pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py DEFAULT_EXCLUSIONS exclude_external_libraries bool if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis. True level_limit Optional [ int ] if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit. None get_evaluable_architecture_for_module_objects ( root_module , module , exclusions = DEFAULT_EXCLUSIONS , exclude_external_libraries = True , level_limit = None ) Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.","title":"General"},{"location":"general/#general","text":"","title":"General"},{"location":"general/#src.pytestarch.pytestarch","text":"The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules.","title":"pytestarch"},{"location":"general/#src.pytestarch.pytestarch.get_evaluable_architecture","text":"Constructs an evaluable object based on the given module. Parameters: Name Type Description Default root_path str root directory of the source code required module_path str path of module to generate the evaluable for. Must be a submodule of the root_path module. required exclusions Tuple [ str , ...] pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py DEFAULT_EXCLUSIONS exclude_external_libraries bool if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis. True level_limit Optional [ int ] if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit. None","title":"get_evaluable_architecture()"},{"location":"general/#src.pytestarch.pytestarch.get_evaluable_architecture_for_module_objects","text":"Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.","title":"get_evaluable_architecture_for_module_objects()"},{"location":"parsing/","text":"Parsing converter ImportConverter Converts all ast imports to custom import types. convert ( asts ) Converts ast modules to custom import modules. Filters out all modules that are not imports. Parameters: Name Type Description Default asts List [ NamedModule ] list of ast modules required Returns: Type Description List [ Import ] list of import objects file_filter FileFilter Uses a pseudo-regex pattern to determine whether a file or directory should be excluded. Allowed patterns are: - A : file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A : file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A' is_excluded ( path ) Returns True if the path matches one of the pre-configured exclusion patterns. import_filter ImportFilter Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports. __init__ ( exclude_external_libraries , root_module_path ) Parameters: Name Type Description Default exclude_external_libraries bool If True, external modules will be filtered out, otherwise this class implements a no-op. required root_module_path Path path to the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal. required filter ( imports ) According to the configuration, imports will be filtered. Parameters: Name Type Description Default imports List [ Import ] list of imports to be filtered required Returns: Type Description List [ Import ] filtered list of imports import_types AbsoluteImport Bases: Import Represents an absolute import. Import Bases: ABC importee () abstractmethod Returns name of a module that is being imported. Returns: Type Description str module name importee_parent_modules () abstractmethod Returns names of all parent modules of the imported module. Returns: Type Description List [ str ] list of module names importer () Returns name of the module that imports something. Returns: Type Description str module name importer_parent_modules () Returns names of all parent modules of the importing module. Returns: Type Description List [ str ] list of module names NamedModule dataclass Contains an ast module with its name. Attributes: Name Type Description module ast . Module ast module object name str module name RelativeImport Bases: Import Represents a relative import. importee_module_calculator ImporteeModuleCalculator Adds all parent modules of imported modules if they are not yet part of the modules list. calculate_importee_modules ( imports , all_modules ) For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies. Parameters: Name Type Description Default imports List [ Import ] required all_modules List [ str ] required Returns: Type Description List [ str ] all modules extended by parent modules of imported modules parser Parser Parses all files that match given criteria starting at a source path. parse ( path ) Reads all python files in the given path and returns list of ast modules with names. Parameters: Name Type Description Default path Path either to a file or to a directory required Returns: Type Description Tuple [ List [ str ], List [ NamedModule ]] list of python modules, one per python file","title":"Parsing"},{"location":"parsing/#parsing","text":"","title":"Parsing"},{"location":"parsing/#src.pytestarch.importer.converter","text":"","title":"converter"},{"location":"parsing/#src.pytestarch.importer.converter.ImportConverter","text":"Converts all ast imports to custom import types.","title":"ImportConverter"},{"location":"parsing/#src.pytestarch.importer.converter.ImportConverter.convert","text":"Converts ast modules to custom import modules. Filters out all modules that are not imports. Parameters: Name Type Description Default asts List [ NamedModule ] list of ast modules required Returns: Type Description List [ Import ] list of import objects","title":"convert()"},{"location":"parsing/#src.pytestarch.importer.file_filter","text":"","title":"file_filter"},{"location":"parsing/#src.pytestarch.importer.file_filter.FileFilter","text":"Uses a pseudo-regex pattern to determine whether a file or directory should be excluded. Allowed patterns are: - A : file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A : file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A'","title":"FileFilter"},{"location":"parsing/#src.pytestarch.importer.file_filter.FileFilter.is_excluded","text":"Returns True if the path matches one of the pre-configured exclusion patterns.","title":"is_excluded()"},{"location":"parsing/#src.pytestarch.importer.import_filter","text":"","title":"import_filter"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter","text":"Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports.","title":"ImportFilter"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter.__init__","text":"Parameters: Name Type Description Default exclude_external_libraries bool If True, external modules will be filtered out, otherwise this class implements a no-op. required root_module_path Path path to the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal. required","title":"__init__()"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter.filter","text":"According to the configuration, imports will be filtered. Parameters: Name Type Description Default imports List [ Import ] list of imports to be filtered required Returns: Type Description List [ Import ] filtered list of imports","title":"filter()"},{"location":"parsing/#src.pytestarch.importer.import_types","text":"","title":"import_types"},{"location":"parsing/#src.pytestarch.importer.import_types.AbsoluteImport","text":"Bases: Import Represents an absolute import.","title":"AbsoluteImport"},{"location":"parsing/#src.pytestarch.importer.import_types.Import","text":"Bases: ABC","title":"Import"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importee","text":"Returns name of a module that is being imported. Returns: Type Description str module name","title":"importee()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importee_parent_modules","text":"Returns names of all parent modules of the imported module. Returns: Type Description List [ str ] list of module names","title":"importee_parent_modules()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importer","text":"Returns name of the module that imports something. Returns: Type Description str module name","title":"importer()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importer_parent_modules","text":"Returns names of all parent modules of the importing module. Returns: Type Description List [ str ] list of module names","title":"importer_parent_modules()"},{"location":"parsing/#src.pytestarch.importer.import_types.NamedModule","text":"Contains an ast module with its name. Attributes: Name Type Description module ast . Module ast module object name str module name","title":"NamedModule"},{"location":"parsing/#src.pytestarch.importer.import_types.RelativeImport","text":"Bases: Import Represents a relative import.","title":"RelativeImport"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator","text":"","title":"importee_module_calculator"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator.ImporteeModuleCalculator","text":"Adds all parent modules of imported modules if they are not yet part of the modules list.","title":"ImporteeModuleCalculator"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator.ImporteeModuleCalculator.calculate_importee_modules","text":"For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies. Parameters: Name Type Description Default imports List [ Import ] required all_modules List [ str ] required Returns: Type Description List [ str ] all modules extended by parent modules of imported modules","title":"calculate_importee_modules()"},{"location":"parsing/#src.pytestarch.importer.parser","text":"","title":"parser"},{"location":"parsing/#src.pytestarch.importer.parser.Parser","text":"Parses all files that match given criteria starting at a source path.","title":"Parser"},{"location":"parsing/#src.pytestarch.importer.parser.Parser.parse","text":"Reads all python files in the given path and returns list of ast modules with names. Parameters: Name Type Description Default path Path either to a file or to a directory required Returns: Type Description Tuple [ List [ str ], List [ NamedModule ]] list of python modules, one per python file","title":"parse()"},{"location":"query_language/","text":"Query Language base_language BehaviorSpecification Bases: ABC Offers functionality to specify whether dependencies are expected or not. DependencySpecification Bases: ABC Offers functionality to specify which kind of dependencies are expected. ModuleSpecification Bases: Generic [ ModuleSpecificationSuccessor ] , ABC Offers functionality to specify detail information about Rule Subjects or Objects. Rule Bases: DependencySpecification , RuleBase , BehaviorSpecification , RuleObject , RuleSubject , RuleApplier Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2 RuleApplier Bases: ABC assert_applies ( evaluable ) abstractmethod Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents. Parameters: Name Type Description Default evaluable EvaluableArchitecture module dependency structure to compare the rule against required Raises: Type Description AssertionError if the rule does not apply to the evaluable object RuleBase Bases: ABC Entry point to each architectural rule. rule_matcher BehaviorRequirement Stores information about which import behavior the checked module is supposed to exhibit. generate_rule_violation ( strict_dependency , lax_dependencies ) Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them. Parameters: Name Type Description Default strict_dependency Optional [ Tuple [ str , str ]] dependency between the two specified modules found required lax_dependencies Set [ Module ] other dependencies found beside the two specified modules required Returns: Type Description RuleViolations overview of all rule violations lax_dependency_not_allowed () property Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement. lax_dependency_required () property Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement. strict_dependency_not_allowed () property Returns True if a dependency between two specific modules is not allowed. strict_dependency_required () property Returns True if a dependency between two specific modules is required. ModuleRequirement Stores information about which module is supposed to be checked against which module. RuleMatcher Bases: ABC Checks whether given modules fulfill the module and behavior requirements that have been specified for them. match ( evaluable ) abstractmethod Checks whether an expected behavior is exhibited by the EvaluableArchitecture. Parameters: Name Type Description Default evaluable EvaluableArchitecture object to check required Returns: Type Description RuleViolations overview of rule violations","title":"Query Language"},{"location":"query_language/#query-language","text":"","title":"Query Language"},{"location":"query_language/#src.pytestarch.query_language.base_language","text":"","title":"base_language"},{"location":"query_language/#src.pytestarch.query_language.base_language.BehaviorSpecification","text":"Bases: ABC Offers functionality to specify whether dependencies are expected or not.","title":"BehaviorSpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.DependencySpecification","text":"Bases: ABC Offers functionality to specify which kind of dependencies are expected.","title":"DependencySpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.ModuleSpecification","text":"Bases: Generic [ ModuleSpecificationSuccessor ] , ABC Offers functionality to specify detail information about Rule Subjects or Objects.","title":"ModuleSpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.Rule","text":"Bases: DependencySpecification , RuleBase , BehaviorSpecification , RuleObject , RuleSubject , RuleApplier Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2","title":"Rule"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleApplier","text":"Bases: ABC","title":"RuleApplier"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleApplier.assert_applies","text":"Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents. Parameters: Name Type Description Default evaluable EvaluableArchitecture module dependency structure to compare the rule against required Raises: Type Description AssertionError if the rule does not apply to the evaluable object","title":"assert_applies()"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleBase","text":"Bases: ABC Entry point to each architectural rule.","title":"RuleBase"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher","text":"","title":"rule_matcher"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement","text":"Stores information about which import behavior the checked module is supposed to exhibit.","title":"BehaviorRequirement"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.generate_rule_violation","text":"Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them. Parameters: Name Type Description Default strict_dependency Optional [ Tuple [ str , str ]] dependency between the two specified modules found required lax_dependencies Set [ Module ] other dependencies found beside the two specified modules required Returns: Type Description RuleViolations overview of all rule violations","title":"generate_rule_violation()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.lax_dependency_not_allowed","text":"Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement.","title":"lax_dependency_not_allowed()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.lax_dependency_required","text":"Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement.","title":"lax_dependency_required()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.strict_dependency_not_allowed","text":"Returns True if a dependency between two specific modules is not allowed.","title":"strict_dependency_not_allowed()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.strict_dependency_required","text":"Returns True if a dependency between two specific modules is required.","title":"strict_dependency_required()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.ModuleRequirement","text":"Stores information about which module is supposed to be checked against which module.","title":"ModuleRequirement"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.RuleMatcher","text":"Bases: ABC Checks whether given modules fulfill the module and behavior requirements that have been specified for them.","title":"RuleMatcher"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.RuleMatcher.match","text":"Checks whether an expected behavior is exhibited by the EvaluableArchitecture. Parameters: Name Type Description Default evaluable EvaluableArchitecture object to check required Returns: Type Description RuleViolations overview of rule violations","title":"match()"}]}