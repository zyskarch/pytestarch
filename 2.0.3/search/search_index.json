{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyTestArch","text":"<p>PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is  generally inspired by ArchUnit.</p>"},{"location":"#installation-guide","title":"Installation Guide","text":"<p>PyTestArch is available via PyPI and can be installed e.g. via pip: <code>pip install pytestarch</code>. To also install the optional dependency matplotlib, which is required to draw the created dependency graphs, install <code>pytestarch[visualization]</code>.</p>"},{"location":"#usage-guide","title":"Usage Guide","text":"<p>Three steps are required to test an architectural rule:</p> <p>1) Create an evaluable representation of the source code you want to test</p> <pre><code>from pytestarch import get_evaluable_architecture\n\nevaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\")\n</code></pre> <p>This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external  dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest, you could use a fixture for this evaluable object.</p> <p>2) Define an architectural rule</p> <pre><code>from pytestarch import Rule\n\nrule = (\n    Rule()\n    .modules_that() \n    .are_named(\"project.src.moduleB\") \n    .should_not() \n    .be_imported_by_modules_that() \n    .are_sub_modules_of(\"project.src.moduleA\")\n)\n</code></pre> <p>This rule represents the architectural requirements that a module named \"project.src.moduleB\" should not be imported by any module that is a submodule of \"project.src.moduleA\", excluding \"project.src.moduleA\" itself.</p> <p>3) Evaluate your code against this rule</p> <pre><code>rule.assert_applies(evaluable)\n</code></pre> <p>That's it!</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project uses semantic versioning and follows keep a changelog.</p>"},{"location":"changelog/#203-2024-03-17","title":"[2.0.3] -- 2024-03-17","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Module resolution for nested modules with root and module path mismatch.</li> </ul>"},{"location":"changelog/#202-2024-03-16","title":"[2.0.2] -- 2024-03-16","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Module resolution for absolute imports when root and module path differ.</li> </ul>"},{"location":"changelog/#201-2024-03-14","title":"[2.0.1] -- 2024-03-14","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Readme description on module name references.</li> </ul>"},{"location":"changelog/#200-2024-02-23","title":"[2.0.0] -- 2024-02-23","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Matplotlib is no longer installed by default, as it is not required for the core functionality.</li> </ul>"},{"location":"changelog/#160-2024-02-23","title":"[1.6.0] -- 2024-02-23","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for mypy.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Syntax for example rules in documentation.</li> </ul>"},{"location":"changelog/#151-2023-11-21","title":"[1.5.1] -- 2023-11-21","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Unnecessary dependency.</li> </ul>"},{"location":"changelog/#150-2023-04-12","title":"[1.5.0] -- 2023-04-12","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>More extensive documentation for the regex matching features.</li> </ul>"},{"location":"changelog/#141-2023-04-09","title":"[1.4.1] -- 2023-04-09","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Import paths in documentation.</li> </ul>"},{"location":"changelog/#140-2023-04-09","title":"[1.4.0] -- 2023-04-09","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Option to specify module names and file exclusions via regex.</li> <li>Support for layer architecture.</li> <li>Batch support for rule subjects.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Complete module hierarchy present in graph, instead of only for modules that are part of an import dependency.</li> <li>Error message only lists violated rule objects when multiple rule objects are defined.</li> </ul>"},{"location":"changelog/#131-2023-01-27","title":"[1.3.1] -- 2023-01-27","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Internal module structure to improve coupling, cohesion.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Support for python3.8.</li> </ul>"},{"location":"changelog/#130-2022-11-28","title":"[1.3.0] -- 2022-11-28","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Reference to modules only by part of their names</li> <li>Aliases for plot labels</li> <li>Test generation from PUML component diagrams</li> </ul>"},{"location":"changelog/#121-2022-10-21","title":"[1.2.1] -- 2022-10-21","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Queries with \"except itself\" excluded too many modules from consideration</li> </ul>"},{"location":"changelog/#120-2022-10-08","title":"[1.2.0] -- 2022-10-08","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Line separator for rule violation messages</li> </ul>"},{"location":"changelog/#111-2022-10-04","title":"[1.1.1] -- 2022-10-04","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Line separator for rule violation messages</li> </ul>"},{"location":"changelog/#110-2022-10-02","title":"[1.1.0] -- 2022-10-02","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Rule objects can be passed in as a list</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>All violations not always returned</li> </ul>"},{"location":"changelog/#103-2022-09-28","title":"[1.0.3] -- 2022-09-28","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Simplified calculation of whether imports are within the project</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Excluded directories no longer searched for parseable files</li> </ul>"},{"location":"changelog/#102-2022-09-28","title":"[1.0.2] -- 2022-09-28","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>All internal modules filtered out if module and root path are not identical and are a sub module of the actual root module.</li> </ul>"},{"location":"changelog/#101-2022-09-27","title":"[1.0.1] -- 2022-09-27","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Module no longer considered if rule asked only for submodules of a given module</li> </ul>"},{"location":"changelog/#100-2022-09-27","title":"[1.0.0] -- 2022-09-27","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Rename entry point methods for clarity</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Reference to outdated code in documentation</li> </ul>"},{"location":"changelog/#010-2022-09-23","title":"[0.1.0] -- 2022-09-23","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>More detailed error message for violations of rules checking for absence of imports</li> <li>Versioning of documentation</li> </ul>"},{"location":"changelog/#010-alpha4-2022-09-23","title":"[0.1.0-alpha.4] -- 2022-09-23","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Documentation for release of PyTestArch</li> <li>More detailed project description</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Computation of dependencies between modules on graph</li> </ul>"},{"location":"changelog/#010-alpha3-2022-09-20","title":"[0.1.0-alpha.3] -- 2022-09-20","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Different construction of graph node names between OS</li> </ul>"},{"location":"changelog/#010-alpha1-2022-09-20","title":"[0.1.0-alpha.1] -- 2022-09-20","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Documentation</li> <li>library MVP</li> </ul>"},{"location":"features/general/","title":"General Concept","text":"<p>PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about  module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the  NetworkX library.</p> <p>When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph.</p>"},{"location":"features/general/#generating-the-evaluable-architecture-representation","title":"Generating the evaluable architecture representation","text":"<p>When scanning and processing the requested modules, PyTestArch executes the following step: 1) Parse all files starting at the requested <code>module_path</code>. This only takes python source files into account that are not explicitly excluded.</p> <p>2) Convert the generated AST into custom dependency representations. In this step, it is ensured that all internal modules (either importing or imported) receive their fully  qualified name.</p> <p>3) Generate a list of all modules that were parsed. This list is used to differentiate between external and internal dependencies (external dependencies will not have been parsed).</p> <p>4) If not requested otherwise, external dependencies will be filtered out.</p> <p>5) If external dependencies should be included, they will be added to the list of modules.</p> <p>6) The dependency representations are converted to a graph structure.</p>"},{"location":"features/general/#simple-example","title":"Simple Example","text":""},{"location":"features/general/#parsing-all-files","title":"Parsing all files","text":"<p>Consider the following project structure:</p> <pre><code>my_project/\n    src/\n        main.py\n        util.py\n        util_test.py\n</code></pre> <p>Both <code>main.py</code> and <code>util_test.py</code> are importing a util function defined in <code>util.py</code>; no other imports exist.</p> <p>With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph:</p> <p></p> <p>Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains,  \"src.main\", \"src.util\", and \"src.util_test\".</p> <p>In addition, a module that imports another module has a directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\".</p>"},{"location":"features/general/#excluding-some-files","title":"Excluding some files","text":"<p>In the example above, the <code>util_test.py</code> file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude <code>util_test.py</code>, we could use:</p> <pre><code>from pytestarch import get_evaluable_architecture\n\nevaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", regex_exclusions=(\".*_test\\.py\"))\n</code></pre> <p>This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories.</p>"},{"location":"features/general/#more-complex-example","title":"More complex example","text":"<p>As a basis for describing the query language, let's consider a more complex example:</p> <pre><code>/test_project\n    /src\n       __init__.py\n       /A\n            __init__.py\n            fileA.py\n            /A1\n                __init__.py\n                fileA1.py\n                fileA1_b.py\n                /A11\n                    __init__.py\n                    fileA11.py\n            /A2\n                __init__.py\n                fileA2.py\n       /B\n            __init__.py\n            fileB.py\n            /B1\n                __init__.py\n                fileB1.py\n                fileB2.py\n       /C \n            __init__.py\n            fileC.py\n</code></pre> <p>With the following list of imports:</p> <ul> <li>fileA imports fileC</li> <li>fileA11 imports fileB1</li> <li>fileA2 imports fileC</li> <li>fileB imports fileA11</li> <li>fileB2 imports fileA11</li> <li>fileC imports the built-in os module</li> </ul> <p>This creates the following graph (excluding all <code>__init__.py</code>):</p> <p></p> <p>Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\".</p> <p>Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all.</p> <p>This has been achieved by setting the <code>exclude_external_libraries</code> flag in the <code>get_evaluable_architecture</code> function. All modules that  not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph.</p> <p></p>"},{"location":"features/general/#additional-notes","title":"Additional Notes","text":""},{"location":"features/general/#root_path-vs-module_path-in-get_evaluable_architecture","title":"root_path vs. module_path in get_evaluable_architecture","text":"<p>The <code>root_path</code> should point towards the most top level module. In the example above, this would be <code>src</code> - not <code>test_project</code>, as <code>test_project</code> is not the top level code directory. The <code>module_path</code> is the module where the dependency scan will start. It has to be either identical to <code>root_path</code> or  a submodule of it.</p>"},{"location":"features/general/#module-names","title":"Module names","text":"<p>In all rules, modules have to be referred to by their fully qualified name, meaning relative to the <code>root_path</code> - not the <code>module_path</code>! This helps to distinguish between internal and external modules.</p>"},{"location":"features/layer_architecture_checks/","title":"Checking dependencies between layers in a layered architecture","text":""},{"location":"features/layer_architecture_checks/#why-are-new-rule-types-needed","title":"Why are new rule types needed?","text":"<p>Sometimes, rules do not concern individual modules, but entire layers of an application, which in turn contains one or  more modules.  The module dependency check methods can of course also be used here, but often they may not be sufficient. Consider an example project with three modules (M, N, O). M imports O, but N does not import anything. M and N belong to one layer - let's call it 'import', O belongs to another layer called 'model'. The 'import' layer is expected to import the 'model'  layer, but not vice versa.</p> <p>Using the module dependency query language as described in Module Dependency Rules, this  expected import behavior would be difficult to specify, as a rule like </p> <pre><code>Rule() \\\n    .modules_that()\\ \n    .are_named([\"M\", \"N\"]) \\\n    .should() \\\n    .import_modules_that() \\\n    .are_named(\"O\")\n</code></pre> <p>would require both M and N to import O.</p>"},{"location":"features/layer_architecture_checks/#layer-architecture-rules","title":"Layer architecture rules","text":"<p>Instead, one can use the layer architecture rules. Using this type of rule has two steps: defining a layered  architecture, and then defining a rule based on it.</p>"},{"location":"features/layer_architecture_checks/#layered-architecture","title":"Layered architecture","text":"<p>The LayeredArchitecture object should be used to group modules into layers. Not all modules have to belong to a layer (for more details on how this influences layer rules, see below). A layered architecture can be defined like this:</p> <pre><code>arch = (\n    LayeredArchitecture() \n    .layer(\"import\") \n    .containing_modules([\"M\", \"N\"]) \n    .layer(\"model\") \n    .containing_modules(\"O\")\n)\n</code></pre> <p>In this layered architecture, the modules M and N belong to layer 'import'; while module O belongs to layer 'model'.</p> <p>Modules can also be specified via a regex, using the method \"have_modules_with_names_matching\".</p> <p>\u26a0 Note that PyTestArch assumes that all submodules of a module belong to the same layer as their parent module!</p>"},{"location":"features/layer_architecture_checks/#layer-rules","title":"Layer rules","text":"<p>After defining a layered architecture, layer rules can not be defined based on it. Using the <code>arch</code> object defined above, the dependency rule that could not properly be defined in the regular syntax can then be defined as:</p> <pre><code>rule = (\n    LayerRule()\n    .based_on(arch).   # needs to be passed in first\n    .layers_that() \n    .are_named(\"import\") \n    .should_only() \n    .access_layers_that() \n    .are_named(\"model\")\n)\n</code></pre> <p>All modules within one layer are treated as one entity. This means that this rule will apply to an evaluable architecture, as long either module M or module N imports module O, and neither imports anything else. This means that for rules that require no dependency between layers, no module of these layers can import another module of these layers. However, for rules that only require one dependency to be present, it is sufficient if there is one  dependency between one module from one layer and one module from the other layer.</p> <p>Note that the \"import\" verb markers of the module dependency rules are replaced by \"access\" here, to mark the difference between these rule types and also to be more in line with ArchUnit's syntax.</p> <p>Not all modules need to belong to layers, but then no layer architecture rules can be specified for them. They will however be considered when evaluating whether  a layer architecture rules applies. For example, module M of layer A imports module N from layer B and module O, which  is not part of any layer. A rule like</p> <pre><code>LayerRule().based_on(arch).layers_that().are_named(\"A\").should_only().access_layers_that().are_named(\"B\")\n</code></pre> <p>would raise an AssertionException, as module M also imports module O.</p> <p>For an explanation of the meaning of the different verb markers used (e.g. should, except) refer to  Module Dependency Rules. The two types of query syntax differ in the following points: 1) \"import\" is replaced by \"access\" 2) Only \"are_named\" rule subject and object specifications are allowed 3) The layer architecture rules need to be started by passing in the layered architecture object that contains the layer  definitions.</p>"},{"location":"features/module_import_checks/","title":"Checking dependencies between modules","text":""},{"location":"features/module_import_checks/#general-structure","title":"General Structure","text":"<p>The query language that can be used to define architectural rules follows this structure: </p> <p>RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT</p> <p>The meaning of these structural markers is described in the table below.</p> Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except <p>The examples given in the table above combined form the rule <code>modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT)</code>.</p> <p>Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing  from the \"B\" module is \"fileA11\", which is a submodule of \"A\".</p>"},{"location":"features/module_import_checks/#features","title":"Features","text":"<p>Currently, the following markers are supported by PyTestArch:</p>"},{"location":"features/module_import_checks/#rule_subject","title":"RULE_SUBJECT","text":"<ul> <li>are_named(\"X\"): applies to module named \"X\" (and also considers its submodules, as submodules are considered to be part of their parent module)</li> <li>are_submodules_of(\"Y\"): applies to submodules of module named \"Y\", but not \"Y\" itself</li> <li>have_name_matching(regex): applies to module with names that match the given regex. </li> </ul> <p>\u26a0 When using the <code>have_name_matching</code> functionality, the regex should ideally only directly match the module one wants to test, not also its submodules. For example, if a module named src.moduleA should be matched, the regex should not also match  src.moduleA.submoduleAA, as this can increase the runtime of the rule assertion check. This has no effect on the  result of the check itself, as submodules are considered to be part of their parent module - for example, if the parent module has to import from module X, this condition is fulfilled if at least one of its submodules imports X.</p> <p>\u26a0 Regex expressions that want to apply a predicate on a module, but not its submodules are not currently supported.  This often happens with regex expressions that contain negations. Consider the following example:</p> <pre><code>foo/\n    bar_test.py (imports from util_test.py)\n    util_test.py\n</code></pre> <p>We want to express that no production code (not ending with _test) may import from test code (ending in _test). A rule with a negation in a regex could look like this: <code>Rule().modules_that().have_name_matching(r\"^((?!test$).)*$\").should_not().import_modules_that().have_name_matching(r\".*test$\")</code> PyTestArch calculates which modules match the first regex - which in this case, is only \"foo\". The second expression matches the two test files. The rule then gets converted to  <code>Rule().modules_that().are_named(\"foo\").should_not().import_modules_that().have_name_matching([\"foo.bar_test\", \"util_test\"])</code> \"Foo\" itself does not import any of the other files. However, the string \"foo\" matches not only \"foo\" itself, but also its submodules, as these are considered to be part of their parent module. In this case, \"foo.bar_test\" is then checked for imports of any test files - and bar_test does import util_test: The rule is marked as violated.</p> <p>Rules like this can usually be expressed without negations, often even by using the general API: An equivalent rule would be <code>Rule().modules_that().have_name_matching(\".*test$\").should_not().be_imported_by_modules_except_modules_that().have_name_matching(\".*test$\")</code></p> <p>Note: If a regex resolves to multiple rule subjects, this is equivalent to specifying the rule independently for both.</p>"},{"location":"features/module_import_checks/#rule_object","title":"RULE_OBJECT","text":"<p>same as RULE_SUBJECT, with an additional</p> <p>anything: can only be used in combination with should_not()</p> <p>In order to reduce the number of possible API component combinations, this rule object has been combined with two verbs into: <code>import_anything()</code> and <code>be_imported_by_anything()</code>. </p> <p>Both RULE_SUBJECTs and RULE_OBJECTs can be specified in batch, i.e. via a list of values. If multiple rule subjects are specified, this has the same effect as defining a rule per rule subject. For example, the rule</p> <pre><code>modules_that() \\\n    .are_named([\"1\", \"2\"]) \\\n    .should_only() \\\n    .be_imported_by_modules_that() \\\n    .are_named([\"3\", \"4\"])\n</code></pre> <p>is fulfilled, it the modules \"1\" and \"2\" both are not imported by any module other than \"3\" and \"4\", and if both \"3\" and \"4\" do import \"1\" and \"2\".</p>"},{"location":"features/module_import_checks/#verb_marker_1","title":"VERB_MARKER_1","text":"<ul> <li>should()</li> <li>should_only()</li> <li>should_not()</li> </ul>"},{"location":"features/module_import_checks/#import_type-verb_marker_2","title":"IMPORT_TYPE + VERB_MARKER_2","text":"<ul> <li>import_modules_that()</li> <li>import_modules_except_modules_that()</li> <li>be_imported_by_modules_that()</li> <li>be_imported_by_modules_except_modules_that()</li> </ul> <p>VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability.</p> <p>Markers from each category can be combined freely with all markers of all other categories. Example rules could be </p> <pre><code>modules_that() \\\n    .are_sub_modules_of(\"A\") \\\n    .should_only() \\\n    .be_imported_by_modules_that() \\\n    .are_sub_modules_of(\"B\") \\\n</code></pre> <p>(True in the above example)</p> <p>or </p> <pre><code>modules_that() \\\n    .are_named(\"C\") \\\n    .should_only() \\\n    .be_imported_by_modules_that() \\\n    .are_named(\"A2\") \\\n</code></pre> <p>(False, also imported by module \"A\")</p> <p>Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo-code for brevity):</p> Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1 <p>There are two aliases to make rules easier:</p> <ul> <li>'M1 should not import anything' is equivalent to: 'M1 should not import anything except itself' (e.g. imports between its submodules are allowed, but no other imports)</li> <li>'M1 should not be imported by anything' is equivalent to: 'M1 should not be imported by anything except itself' (dito)</li> </ul>"},{"location":"features/plantuml/","title":"Testing your architecture based on PlantUML component diagrams","text":""},{"location":"features/plantuml/#general","title":"General","text":"<p>Instead of hand-crafting a number of rules, you can supply the path to a PlantUML component diagram via a <code>DiagramRule</code>. PyTestArch will then parse this file and generate rules based on the connections of nodes in this diagram. Connections between two nodes will be converted into 'should only' or 'should' import rules; the absence of a connection will be converted into 'should not' import rules. All rules are then evaluated against an Evaluable.</p> <p>Currently, parent-child relationships between modules are not supported. This means that for module X and its submodule Y, an edge between them in the diagram will be interpreted as an 'imports' relationship, not a 'submodule relationship'.</p> <p>There are two options for naming the components in your diagram:</p> <p>1) Use their fully qualified name, starting at the root module. For example, in the complex example above, this could be \"src.A.fileA\" instead of just \"fileA\"  2) Use only the name of the module itself, for example \"fileA\". Then you need to supply the prefix left out in the diagrams relative to your root module. In our example,     this would be \"src.A\". PyTestArch will then prefix all components in the diagram with this string. </p>"},{"location":"features/plantuml/#supported-plantuml-language-features","title":"Supported PlantUML language features","text":"<p>Syntactical requirements for .puml files: * start of dependency definition needs to be tagged with @startuml * end of dependency definition needs to be tagged with @enduml * all text outside these tags is ignored * component names must be enclosed in square brackets * exception: if a component as been given an alias via <code>[module name] as alias</code>, then the alias should not be wrapped in square brackets * dependencies must be with either --&gt;, -&gt;, &lt;--, &lt;-, -text-&gt;, or &lt;-text-. The dependee is to be placed on the side of the arrow head, the dependor on the opposite side</p>"},{"location":"features/visualization/","title":"Visualization","text":""},{"location":"features/visualization/#visualizing-architecture","title":"Visualizing architecture","text":"<p>The graph structure can be plotted with <code>evaluable_architecture.visualize()</code> (requires matplotlib - this is not installed as a dependency by default: please install <code>pytestarch[visualization]</code>), which plots the dependency graph. By default, the nodes are labeled with their module name. If a module name is long  and/or a module has many submodules, the labels may crowd the plot. This can be  addressed by specifying (short) aliases for the module names by using the keyword argument  <code>aliases</code>. An alias will replace the module name in the label of the respective module and all its submodules unless the submodule also has an alias, in that case the submodule's alias takes priority.</p>"},{"location":"features/visualization/#alias-examples","title":"Alias Examples:","text":"<p>Consider an architecture with modules <code>long_root_name, long_root_name.submodule, long_root_name.submodule.sub_submodule, long_root_name.other_submodule</code> then the  resulting labels for a given aliases are:</p> aliases labels <code>{'long_root_name': 'r'}</code> <code>r, r.submodule, r.submodule.sub_submodule, r.other_submodule</code> <code>{'long_root_name': 'r', 'long_root_name.submodule': 'sub'}</code> <code>r, sub, sub.sub_submodule, r.other_submodule</code>"},{"location":"references/diagram_extension/","title":"Diagram Extension","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule","title":"<code>diagram_rule</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule.DiagramRule","title":"<code>DiagramRule</code>","text":"<p>         Bases: <code>FileRule</code>, <code>BaseModuleSpecifier</code>, <code>RuleApplier</code></p> <p>Represents a set of architectural rules as defined in a diagram file. Reads the specified file, generates architectural rules, and returns an aggregated test result.</p> <p>By default, \"should only import\" rules will be generated for modules that the diagram shows as connected. \"Should not import\" rules will be generated for modules that are not connected in the diagram.</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_rule.DiagramRule.__init__","title":"<code>__init__(should_only_rule=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>should_only_rule</code> <code>bool</code> <p>if True, edges between components will be converted into 'should only import' rules.</p> <code>True</code>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter","title":"<code>dependency_to_rule_converter</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter.DependencyToRuleConverter","title":"<code>DependencyToRuleConverter</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.dependency_to_rule_converter.DependencyToRuleConverter.convert","title":"<code>convert(dependencies)</code>","text":"<p>Converts a parsed dependency object to a list of RuleAppliers. All explicit dependencies in the given object are converted to should (only) rules. All missing, but possible dependencies between the given modules are converted to 'should not' rules.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>ParsedDependencies</code> <p>parsed modules and dependencies between modules</p> required <p>Returns:</p> Type Description <code>List[RuleApplier]</code> <p>list of RuleAppliers that can be applied to an evaluable</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser","title":"<code>diagram_parser</code>","text":""},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser.PumlParser","title":"<code>PumlParser</code>","text":"<p>         Bases: <code>DiagramParser</code></p> <p>Parses .puml files to a dependencies object that can be used to generate architecture rules.</p>"},{"location":"references/diagram_extension/#src.pytestarch.diagram_extension.diagram_parser.PumlParser.parse","title":"<code>parse(file_path)</code>","text":"<p>Syntactical requirements for .puml files:     * start of dependency definition needs to be tagged with @startuml     * end of dependency definition needs to be tagged with @enduml     * all text outside these tags is ignored     * component names must be enclosed in square brackets     * exception: if a component as been given an alias via <code>[module name] as alias</code>, then the alias should not be         wrapped in square brackets     * dependencies must be with either --&gt;, -&gt;, &lt;--, &lt;-, -text-&gt;, or &lt;-text-. The dependee is to be placed         on the side of the arrow head, the dependor on the opposite side</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>.puml file to parse</p> required <p>Returns:</p> Type Description <code>ParsedDependencies</code> <p>dependencies object that can be used to generate architecture rules.</p>"},{"location":"references/eval_structure/","title":"Evaluation Structures","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture","title":"<code>evaluable_architecture</code>","text":"<p>Abstract interface of evaluable objects.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture","title":"<code>EvaluableArchitecture</code>","text":"<p>         Bases: <code>Protocol</code></p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.modules","title":"<code>modules: List[str]</code>  <code>property</code>","text":"<p>Return names of all modules that are present in this architecture.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_dependencies_from_dependents_to_modules_other_than_dependent_upons","title":"<code>any_dependencies_from_dependents_to_modules_other_than_dependent_upons(dependents, dependent_upons)</code>","text":"<p>Returns list of depending modules per dependent module if the dependent module has any dependency to a module other than the dependent_upon modules or any of their submodules.</p> <p>If a dependent module is defined via a parent module, this parent module is not taken into account. If a dependent upon module is defined via a parent module, this parent module counts as an 'other' dependency.     Reason behind this: If we want to know whether there are any dependencies from X to any non-Y modules,     Y's parent is such a module, as this parent module can and usually will also contain other modules than Y.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module</p> required <code>dependent_upon</code> <p>Module</p> required <p>Returns:</p> Type Description <code>NotExplicitlyRequestedDependenciesByBaseModule</code> <p>All modules other than dependent_upon on which dependent module as any dependency per dependent module</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_other_dependencies_on_dependent_upons_than_from_dependents","title":"<code>any_other_dependencies_on_dependent_upons_than_from_dependents(dependents, dependent_upons)</code>","text":"<p>Returns list of depending modules per dependent_upon module if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. If the dependent module is defined via a parent module, this parent module is taken into account. This means that if the dependent module's parent module has a dependency to the dependent upon module, this will be contained in the returned list. If the dependent upon module is defined via a parent module, this parent module is not taken into account.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module</p> required <code>dependent_upon</code> <p>Module</p> required <p>Returns:</p> Type Description <code>NotExplicitlyRequestedDependenciesByBaseModule</code> <p>All modules other than dependent that have any dependency on the dependent upon module per dependent_upon module</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.get_dependencies","title":"<code>get_dependencies(dependents, dependent_upons)</code>","text":"<p>Returns tuple of importer and importee per dependent and depending module if the dependent module is indeed depending on the dependent_upon module. In short: find all dependencies between dependent and dependent_upons.</p> <p>Submodules of dependent and dependent upon are taken into account. If X.A depends on Y, then X also depends on Y, as X.A is part of X. If X depends on Y.Z, then it also depends on Y.</p> <p>If one or both of the modules are defined by their parent module, this parent module is excluded from possible matches.</p> <p>Parameters:</p> Name Type Description Default <code>dependent</code> <p>Module(s)</p> required <code>dependent_upon</code> <p>Module(s)</p> required <p>Returns:</p> Type Description <code>ExplicitlyRequestedDependenciesByBaseModules</code> <p>Importer and importee per pair of dependent and dependent_upon module if there are any</p> <code>ExplicitlyRequestedDependenciesByBaseModules</code> <p>that are sub modules of dependent and dependent_upon respectively.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.visualize","title":"<code>visualize(**kwargs)</code>","text":"<p>Uses matplotlib to draw the underlying dependency structure.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout).</p> <code>{}</code>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.LayerMapping","title":"<code>LayerMapping</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.LayerMapping.get_layer_for_module_name","title":"<code>get_layer_for_module_name(module_name)</code>","text":"<p>Attempts to find the layer the given module belongs to. If the module does not appear in the layer definition itself, it is checked whether the module is a submodule of one of the modules in the layer definition. If so, the layer of the parent module is returned. Otherwise, None is returned. This assumes that if a module is in layer X, all of its submodules are as well.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.Module","title":"<code>Module</code>  <code>dataclass</code>","text":"<p>Represents an actual python module found in the dependency graph.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.ModuleFilter","title":"<code>ModuleFilter</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Represents a way to identify a python module in the dependency graph.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.ModuleGroup","title":"<code>ModuleGroup</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Module</code></p> <p>Represents a group of actual python module found in the dependency graph. This is only needed if a group of modules is specified via their parent module's name, and only for not explicitly requested dependencies. For these, the original module filter is not converted to actual modules, as this would clutter the return type and the user output. Instead, this filter will be converted to a module group.</p> <p>The name is the name of the parent module of all modules in this group.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.ModuleNameFilter","title":"<code>ModuleNameFilter</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ModuleFilter</code></p> <p>Represents a way to identify a python module in the dependency graph by its name.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.ModuleNameRegexFilter","title":"<code>ModuleNameRegexFilter</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ModuleFilter</code></p> <p>Represents a way to identify a python module in the dependency graph. The module is identified by a regex pattern for its name.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.ParentModuleNameFilter","title":"<code>ParentModuleNameFilter</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ModuleFilter</code></p> <p>Represents a way to identify a python module in the dependency graph by the name of its parent module.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_graph","title":"<code>evaluable_graph</code>","text":"<p>Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.evaluable_graph.EvaluableArchitectureGraph","title":"<code>EvaluableArchitectureGraph</code>","text":"<p>         Bases: <code>EvaluableArchitecture</code></p> <p>Abstract implementation of an evaluable object that is based on a graph structure.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.module_name_converter","title":"<code>module_name_converter</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.module_name_converter.ModuleNameConverter","title":"<code>ModuleNameConverter</code>","text":"<p>Converts module names specified via regex pattern to module names based on which modules in the architecture match the regex pattern.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.module_name_converter.ModuleNameConverter.convert","title":"<code>convert(modules, arch)</code>  <code>classmethod</code>","text":"<p>Converts each regex pattern that serves to identify module names into actual modules that match this pattern.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>modules</code> <p>list of modules, some of which may need converting since their names are regex patterns</p> required <code>-</code> <code>arch</code> <p>architecture that contains actual modules</p> required <p>Returns:</p> Type Description <code>Sequence[ModuleFilter]</code> <ul> <li>list of module filters, now without any regex patterns. Will be used for later dependency graph queries.</li> </ul> <code>Dict[str, List[Module]]</code> <ul> <li>mapping between a regex pattern and the actual modules it was replaced by</li> </ul>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph","title":"<code>networkxgraph</code>","text":"<p>Encapsulation of networkx graph functionality.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph","title":"<code>NetworkxGraph</code>","text":"<p>         Bases: <code>AbstractGraph</code></p> <p>Constructs eval_structure from list of imports.</p> <p>Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy.</p> <p>E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')]</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.__init__","title":"<code>__init__(all_modules, imports, level_limit=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>all_modules</code> <code>List[Node]</code> <p>list of all nodes in the graph, which can be connected by imports.</p> required <code>imports</code> <code>Sequence[Import]</code> <p>all dependencies between the graph's nodes.</p> required <code>level_limit</code> <code>Optional[int]</code> <p>if not None, specifies the depth of the graph</p> <code>None</code>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.direct_predecessor_nodes","title":"<code>direct_predecessor_nodes(node)</code>","text":"<p>Returns all nodes that have a directed edge towards the given node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node for which to retrieve predecessor nodes</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>all predecessor nodes</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.direct_successor_nodes","title":"<code>direct_successor_nodes(node)</code>","text":"<p>Returns all nodes that the given node has a directed edge towards.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node for which to retrieve successor nodes</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>all successor nodes</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.draw","title":"<code>draw(**kwargs)</code>","text":"<p>Creates a matplotlib plot representing the graph.</p> <p>Other Parameters:</p> Name Type Description <code>spacing</code> <code>float</code> <p>optimal distance between nodes</p> <code>aliases</code> <code>Dict[str, str]</code> <p>module name aliases for plot labels. Keys are module names and values the aliases. If no alias is specified the module name is used a node label. If a module name has an alias, the module name is replaced by the alias for the module and all its submodules, e.g. for modules a, a.b, a.c, a.c.d and aliases == {'a', 'A'}, the plot labels for these modules will be A, A.b, A.c, A.c.d. If a submodule also has an alias, the alias for the submodule takes priority, e.g. with the same modules as above and aliases == {'a': 'A', 'a.c': 'C'} the plot labels will be A, A.b, C, C.d.</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.networkxgraph.NetworkxGraph.parent_child_relationship","title":"<code>parent_child_relationship(supposed_parent_node, supposed_child_node)</code>","text":"<p>Returns True if the given nodes are marked as a parent-child hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>supposed_parent_node</code> <code>Node</code> required <code>supposed_child_node</code> <code>Node</code> required <p>Returns:</p> Type Description <code>bool</code> <p>True if supposed parent is actually parent of supposed child node</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types","title":"<code>types</code>","text":""},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import","title":"<code>Import</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importee","title":"<code>importee()</code>  <code>abstractmethod</code>","text":"<p>Returns name of a module that is being imported.</p> <p>Returns:</p> Type Description <code>str</code> <p>module name</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importee_parent_modules","title":"<code>importee_parent_modules()</code>  <code>abstractmethod</code>","text":"<p>Returns names of all parent modules of the imported module.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of module names</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importer","title":"<code>importer()</code>","text":"<p>Returns name of the module that imports something.</p> <p>Returns:</p> Type Description <code>str</code> <p>module name</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.Import.importer_parent_modules","title":"<code>importer_parent_modules()</code>","text":"<p>Returns names of all parent modules of the importing module.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of module names</p>"},{"location":"references/eval_structure/#src.pytestarch.eval_structure.types.get_parent_modules","title":"<code>get_parent_modules(module)</code>","text":"<p>Calculates all parent modules of a given module.</p> <p>Example: source root is a module: a.b.c returned: [a, a.b]</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>module to calculate parent modules for</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of all parent modules, containing their full names up to the source code root.</p>"},{"location":"references/eval_structure_generation/","title":"Evaluation Structure Generation","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation","title":"<code>eval_structure_generation</code>","text":"<p>Contains all functionality relating to loading and parsing python source code and creating custom import objects representing the dependencies between the modules.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter","title":"<code>file_filter</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter.FileFilter","title":"<code>FileFilter</code>","text":"<p>Uses a pseudo-regex pattern to determine whether a file or directory should be excluded.</p> <p>Allowed patterns are: - A: file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A: file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A'</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.file_filter.FileFilter.is_excluded","title":"<code>is_excluded(path)</code>","text":"<p>Returns True if the path matches one of the pre-configured exclusion patterns.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter","title":"<code>import_filter</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter","title":"<code>ImportFilter</code>","text":"<p>Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter.__init__","title":"<code>__init__(exclude_external_libraries, root_module_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>exclude_external_libraries</code> <code>bool</code> <p>If True, external modules will be filtered out, otherwise this class implements a no-op.</p> required <code>root_module_name</code> <code>str</code> <p>name of the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal.</p> required"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_filter.ImportFilter.filter","title":"<code>filter(imports)</code>","text":"<p>According to the configuration, imports will be filtered.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Sequence[Import]</code> <p>list of imports to be filtered</p> required <p>Returns:</p> Type Description <code>Sequence[Import]</code> <p>filtered list of imports</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types","title":"<code>import_types</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.AbsoluteImport","title":"<code>AbsoluteImport</code>","text":"<p>         Bases: <code>Import</code></p> <p>Represents an absolute import.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.NamedModule","title":"<code>NamedModule</code>  <code>dataclass</code>","text":"<p>Contains an ast module with its name.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>ast.Module</code> <p>ast module object</p> <code>name</code> <code>str</code> <p>module name</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.import_types.RelativeImport","title":"<code>RelativeImport</code>","text":"<p>         Bases: <code>Import</code></p> <p>Represents a relative import.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator","title":"<code>importee_module_calculator</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator.ImporteeModuleCalculator","title":"<code>ImporteeModuleCalculator</code>","text":"<p>Adds all parent modules of imported modules if they are not yet part of the modules list.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.importee_module_calculator.ImporteeModuleCalculator.calculate_importee_modules","title":"<code>calculate_importee_modules(imports, all_modules)</code>","text":"<p>For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Sequence[Import]</code> required <code>all_modules</code> <code>List[str]</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>all modules extended by parent modules of imported modules</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser","title":"<code>parser</code>","text":""},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser.Parser","title":"<code>Parser</code>","text":"<p>Parses all files that match given criteria starting at a source path.</p>"},{"location":"references/eval_structure_generation/#src.pytestarch.eval_structure_generation.file_import.parser.Parser.parse","title":"<code>parse(path)</code>","text":"<p>Reads all python files in the given path and returns list of ast modules with names.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>either to a file or to a directory</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[NamedModule]]</code> <p>list of python modules, one per python file</p>"},{"location":"references/general/","title":"General","text":""},{"location":"references/general/#src.pytestarch.pytestarch","title":"<code>pytestarch</code>","text":"<p>The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules.</p>"},{"location":"references/general/#src.pytestarch.pytestarch.get_evaluable_architecture","title":"<code>get_evaluable_architecture(root_path, module_path, exclusions=DEFAULT_EXCLUSIONS, exclude_external_libraries=True, level_limit=None, regex_exclusions=None)</code>","text":"<p>Constructs an evaluable object based on the given module.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>root directory of the source code. Should not be set to a submodule of the top level module.</p> required <code>module_path</code> <code>str</code> <p>path of module to generate the evaluable for. Must be a submodule of the root_path module.</p> required <code>exclusions</code> <code>Tuple[str, ...]</code> <p>pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py</p> <code>DEFAULT_EXCLUSIONS</code> <code>exclude_external_libraries</code> <code>bool</code> <p>if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis. Can only be specified if regex_exclusions is not specified.</p> <code>True</code> <code>level_limit</code> <code>Optional[int]</code> <p>if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit.</p> <code>None</code> <code>regex_exclusions</code> <code>Optional[Tuple[str, ...]]</code> <p>Proper regex version of 'exclusions'. Can only be specified if regex_exclusions is not specified.</p> <code>None</code>"},{"location":"references/general/#src.pytestarch.pytestarch.get_evaluable_architecture_for_module_objects","title":"<code>get_evaluable_architecture_for_module_objects(root_module, module, exclusions=DEFAULT_EXCLUSIONS, exclude_external_libraries=True, level_limit=None, regex_exclusions=None)</code>","text":"<p>Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.</p>"},{"location":"references/query_language/","title":"Query Language","text":""},{"location":"references/query_language/#src.pytestarch.query_language.base_language","title":"<code>base_language</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.base_language.AccessSpecification","title":"<code>AccessSpecification</code>","text":"<p>         Bases: <code>RelationshipSpecification</code>, <code>ABC</code></p> <p>Offers functionality to specify which kind of imports between layers in a layer architecture are expected. Access is defined as the layer equivalent of import between modules, e.g. if layer L consists of module X, and layer M of module Y, layer L accesses layer M if module X import module Y.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseLayeredArchitecture","title":"<code>BaseLayeredArchitecture</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseLayeredArchitecture.with_layer","title":"<code>with_layer()</code>  <code>abstractmethod</code>","text":"<p>This is simply a convenience method to achieve proper typing. It can be omitted.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier","title":"<code>BaseModuleSpecifier</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier.base_module_included_in_module_names","title":"<code>base_module_included_in_module_names()</code>  <code>abstractmethod</code>","text":"<p>If the diagram contains fully qualified module names.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BaseModuleSpecifier.with_base_module","title":"<code>with_base_module(name_relative_to_root)</code>  <code>abstractmethod</code>","text":"<p>Sets the name of the base module that was turned into an Evaluable. This enables the user to not having to include the entire name relative to the root module in the diagram. Example: root module is named 'src' Base module: my_project diagram generated for modules in src.my_project.components:     src.my_project.components.A, src.my_project.components.B     -&gt; components are named 'A', 'B' in diagram name_relative_to_root: src.my_project.components</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.BehaviorBaseSpecification","title":"<code>BehaviorBaseSpecification</code>","text":"<p>         Bases: <code>Generic[U]</code>, <code>ABC</code></p> <p>Offers functionality to specify whether dependencies are expected or not.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.DependencySpecification","title":"<code>DependencySpecification</code>","text":"<p>         Bases: <code>RelationshipSpecification</code>, <code>ABC</code></p> <p>Offers functionality to specify which kind of dependencies are expected.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.FileRule","title":"<code>FileRule</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.FileRule.from_file","title":"<code>from_file(file_path)</code>  <code>abstractmethod</code>","text":"<p>Set the path to the file containing the rules that should be applied to the evaluable.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerBase","title":"<code>LayerBase</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Offers an entry point to specifying detailed information about Layer Rule Subjects.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerDefinition","title":"<code>LayerDefinition</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Offers functionality to define which modules a layer contains. Can either be a single or multiple modules.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerDefinition.containing_modules","title":"<code>containing_modules(modules)</code>  <code>abstractmethod</code>","text":"<p>If a module is defined as belonging to layer X, then its submodules are also assumed to be part of layer X.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerDefinition.have_modules_with_names_matching","title":"<code>have_modules_with_names_matching(regex)</code>  <code>abstractmethod</code>","text":"<p>If a module is defined as belonging to layer X, then its submodules are also assumed to be part of layer X. Note that no attempt will be made to ensure that the regex patterns for different layers are mutually exclusive. Also note that regex expressions can have unexpected results if predicates apply to modules, but not their submodules. This is often the case for regex expressions with negations. Refer to the documentation of the module import feature for more details.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerName","title":"<code>LayerName</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Offers functionality to specify the name of a yet to be defined layer.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerRuleBase","title":"<code>LayerRuleBase</code>","text":"<p>         Bases: <code>Generic[X]</code></p> <p>Entry point to defining a rule based on a layered architecture.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.LayerSpecification","title":"<code>LayerSpecification</code>","text":"<p>         Bases: <code>Generic[LayerSpecificationSuccessor, InputTypes]</code>, <code>ABC</code></p> <p>Offers functionality to specify detail information about Layer Rule Subjects or Objects.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification","title":"<code>ModuleSpecification</code>","text":"<p>         Bases: <code>Generic[ModuleSpecificationSuccessor]</code>, <code>ABC</code></p> <p>Offers functionality to specify detail information about Rule Subjects or Objects.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification.are_named","title":"<code>are_named(names)</code>  <code>abstractmethod</code>","text":"<p>If multiple rule subjects are specified, this has the same effect as defining a rule per rule subject.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification.are_sub_modules_of","title":"<code>are_sub_modules_of(modules)</code>  <code>abstractmethod</code>","text":"<p>If multiple rule subjects are specified, this has the same effect as defining a rule per rule subject.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification.have_name_containing","title":"<code>have_name_containing(partial_name)</code>  <code>abstractmethod</code>","text":"<p>[DEPRECATED] Use have_name_matching instead; method will be removed in upcoming releases. If multiple rule subjects are specified, this has the same effect as defining a rule per rule subject.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.ModuleSpecification.have_name_matching","title":"<code>have_name_matching(regex)</code>  <code>abstractmethod</code>","text":"<p>Note that regex expressions can have unexpected results if predicates apply to modules, but not their submodules. This is often the case for regex expressions with negations. Refer to the documentation of the module import feature for more details. If multiple rule subjects are specified, this has the same effect as defining a rule per rule subject.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RelationshipSpecification","title":"<code>RelationshipSpecification</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for different types of relationships between modules, layers, etc.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleApplier","title":"<code>RuleApplier</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleApplier.assert_applies","title":"<code>assert_applies(evaluable)</code>  <code>abstractmethod</code>","text":"<p>Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> <p>module dependency structure to compare the rule against</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the rule does not apply to the evaluable object</p>"},{"location":"references/query_language/#src.pytestarch.query_language.base_language.RuleBase","title":"<code>RuleBase</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Entry point to each architectural rule.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.rule","title":"<code>rule</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.rule.Rule","title":"<code>Rule</code>","text":"<p>         Bases: <code>DependencySpecification</code>, <code>RuleBase</code>, <code>BehaviorSpecification</code>, <code>RuleObject</code>, <code>RuleSubject</code>, <code>RuleApplier</code></p> <p>Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2</p>"},{"location":"references/query_language/#src.pytestarch.query_language.layered_architecture_rule","title":"<code>layered_architecture_rule</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.layered_architecture_rule.LayerRule","title":"<code>LayerRule</code>","text":"<p>         Bases: <code>RuleApplier</code>, <code>LayerRuleBase[LayeredArchitecture]</code>, <code>LayerRuleSubject</code>, <code>LayerRuleObject</code>, <code>AccessSpecification</code>, <code>LayerBehaviorSpecification</code>, <code>LayerSpecification</code>, <code>LayerBase</code></p> <p>Represents an architectural rule of the form Layer X [verb, such as 'should'] [access type, such as 'be accessed by'] Layer Y The modules that each layer contains are to be specified via a LayeredArchitecture object.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.layered_architecture_rule.LayeredArchitecture","title":"<code>LayeredArchitecture</code>","text":"<p>         Bases: <code>BaseLayeredArchitecture</code>, <code>LayerName</code>, <code>LayerDefinition</code></p> <p>Can be used to define layers within an architecture that are each comprised of modules. Note that if a module X is specified as belonging to layer L, all of its submodules are assumed to be part of layer L as well.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.layered_architecture_rule.LayeredArchitecture.with_layer","title":"<code>with_layer()</code>","text":"<p>This is simply a convenience method to achieve proper typing. It can be omitted.</p>"},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier","title":"<code>multiple_rule_applier</code>","text":""},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier.MultipleRuleApplier","title":"<code>MultipleRuleApplier</code>","text":"<p>         Bases: <code>RuleApplier</code></p>"},{"location":"references/query_language/#src.pytestarch.query_language.multiple_rule_applier.MultipleRuleApplier.assert_applies","title":"<code>assert_applies(evaluable)</code>","text":"<p>Checks a number of rules against the given evaluable and returns an aggregated error message if at least one tests fails.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> required"},{"location":"references/rule_assessment/","title":"Rule Assessment","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator","title":"<code>message_generator</code>","text":"<p>Converts a RuleViolations object into a human-readable format.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.LayerRuleViolationMessageGenerator","title":"<code>LayerRuleViolationMessageGenerator</code>","text":"<p>         Bases: <code>RuleViolationMessageGenerator</code></p> <p>Generates a user-friendly error message for each violated rule defined on layers (as compared to modules). These messages differ slightly from messages generated for rules based on modules: 1) For absent, but expected dependencies, the verb used mirrors the verb used in the rule itself (\"access\" instead of \"import\"). 2) For unwanted dependencies, the regular syntax is used, but with an added hint on which layers the problematic modules  belong to, such as \"module X (layer L) imports module Y (layer M)\". If a module does not belong to any layer, (no layer)  will be used.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageBaseGenerator","title":"<code>RuleViolationMessageBaseGenerator</code>","text":"<p>         Bases: <code>ABC</code></p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageBaseGenerator.create_rule_violation_messages","title":"<code>create_rule_violation_messages(rule_violations)</code>","text":"<p>Create a message about each rule violation.</p> <p>Parameters:</p> Name Type Description Default <code>rule_violations</code> <code>RuleViolations</code> <p>to convert to human-readable format</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>set of messages, each representing a rule violation</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator","title":"<code>RuleViolationMessageGenerator</code>","text":"<p>         Bases: <code>RuleViolationMessageBaseGenerator</code></p> <p>Generates a user-friendly error message for each violated rule defined on modules (as compared to layers).</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.error_message.message_generator.RuleViolationMessageGenerator.__init__","title":"<code>__init__(import_rule)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>import_rule</code> <code>bool</code> <p>True if the underlying rule is an \"import\" instead of an \"is imported\" rule</p> required"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher","title":"<code>rule_matcher</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.DefaultRuleMatcher","title":"<code>DefaultRuleMatcher</code>","text":"<p>         Bases: <code>RuleMatcher</code></p> <p>To be used for rules that operate on modules, such as \"module X should not import module Y.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.LayerRuleMatcher","title":"<code>LayerRuleMatcher</code>","text":"<p>         Bases: <code>RuleMatcher</code></p> <p>To be used for rules that operate on layers, such as \"layer X should not access layer Y. These types of rules differ from the DefaultRuleMatcher in that detected dependencies are interpreted differently. Example: Consider the rule 'modules X, Y should import module Z'. In the default case, this means that both X and Y have to import Z for the rule to apply to the evaluable. For the layer rule 'layer L containing modules X, Y should import layer M containing module Z' it is however sufficient for either X or Y to import Z.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.RuleMatcher","title":"<code>RuleMatcher</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Checks whether given modules fulfill the module and behavior requirements that have been specified for them.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_matcher.RuleMatcher.match","title":"<code>match(evaluable)</code>","text":"<p>Checks whether an expected behavior is exhibited by the EvaluableArchitecture. If there are any rule violations, will raise an error detailing the violations.</p> <p>Parameters:</p> Name Type Description Default <code>evaluable</code> <code>EvaluableArchitecture</code> <p>object to check</p> required"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_violation_detector","title":"<code>rule_violation_detector</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_violation_detector.RuleViolationBaseDetector","title":"<code>RuleViolationBaseDetector</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for all classes that detect inconsistencies between the dependencies found within the evaluable architecture and the module and behavior requirements.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_violation_detector.RuleViolationBaseDetector.get_rule_violation","title":"<code>get_rule_violation(explicitly_requested_dependencies, not_explicitly_requested_dependencies)</code>","text":"<p>Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them.</p> <p>Parameters:</p> Name Type Description Default <code>explicitly_requested_dependencies</code> <code>Optional[ExplicitlyRequestedDependenciesByBaseModules]</code> <p>dependency between the specified modules found, grouped by requested modules</p> required <code>not_explicitly_requested_dependencies</code> <code>Optional[NotExplicitlyRequestedDependenciesByBaseModule]</code> <p>other dependencies found beside the specified modules</p> required <p>Returns:</p> Type Description <code>RuleViolations</code> <p>overview of all rule violations</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.rule_violation_detector.RuleViolationDetector","title":"<code>RuleViolationDetector</code>","text":"<p>         Bases: <code>RuleViolationBaseDetector</code></p> <p>Based on the behavior requirement and the dependencies that have actually been (not) found in the graph, this class decides whether any of the requirements have been violated and how.</p> <p>ExplicitlyRequestedDependenciesByBaseModules follow this structure: {(requested dependency, e.g. from A to B): [list of dependencies found that qualifiy as the requested dependency, e.g. A.a1 imports B, A.a2 imports B]}</p> <p>NotExplicitlyRequestedDependenciesByBaseModule on the other hand are structured like this: {Module for which not explicitly requested dependencies (either from or to this module) were found: [list of such dependencies]}.</p> <p>The output is a rule violation object which for each type of rule contains a list of (rule subject, rule object) modules which violate the rule. These are ordered according to the order the user used when specifying the rule, i.e. the rule subject is the original rule subject no matter if the rule is an import or be imported rule.</p> <p>If multiple rule subjects have been specified, the rule needs to apply to each one of them in order not to count as being violated.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.layer_rule_violation_detector","title":"<code>layer_rule_violation_detector</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.layer_rule_violation_detector.LayerRuleViolationDetector","title":"<code>LayerRuleViolationDetector</code>","text":"<p>         Bases: <code>RuleViolationBaseDetector</code></p> <p>Detects violation of a layer rule based on the rule and detected dependencies relevant to this rule. Compared to the regular RuleViolationDetector, this detector is more lenient: For example, for a rule in the style of \"layer X should import layer Y\", it is sufficient if only one module from layer X imports something from layer Y. The regular detector would instead require all modules from layer X to import something from layer Y.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement","title":"<code>behavior_requirement</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement","title":"<code>BehaviorRequirement</code>","text":"<p>Stores information about which import behavior the checked module is supposed to exhibit.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.explicitly_requested_dependency_not_allowed","title":"<code>explicitly_requested_dependency_not_allowed: bool</code>  <code>property</code>","text":"<p>Returns True if the dependency between two specific modules is not allowed.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.explicitly_requested_dependency_required","title":"<code>explicitly_requested_dependency_required: bool</code>  <code>property</code>","text":"<p>Returns True if the dependency between two specific modules is required.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.not_explicitly_requested_dependency_not_allowed","title":"<code>not_explicitly_requested_dependency_not_allowed: bool</code>  <code>property</code>","text":"<p>Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.behavior_requirement.BehaviorRequirement.not_explicitly_requested_dependency_required","title":"<code>not_explicitly_requested_dependency_required: bool</code>  <code>property</code>","text":"<p>Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement.</p>"},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.module_requirement","title":"<code>module_requirement</code>","text":""},{"location":"references/rule_assessment/#src.pytestarch.rule_assessment.rule_check.module_requirement.ModuleRequirement","title":"<code>ModuleRequirement</code>","text":"<p>Stores information about which module is supposed to be checked against which module.</p>"}]}