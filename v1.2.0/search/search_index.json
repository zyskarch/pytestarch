{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyTestArch PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is generally inspired by ArchUnit . Installation Guide PyTestArch is available via PyPI and can be installed e.g. via pip: pip install pytestarch . Usage Guide Three steps are required to test an architectural rule: 1) Create an evaluable representation of the source code you want to test from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\") This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest , you could use a fixture for this evaluable object. 2) Define an architectural rule from pytestarch.query_language.base_language import Rule rule = Rule() .modules_that() .are_named(\"src.moduleB\") .should_not() .be_imported_by_modules_that() .are_sub_modules_of(\"src.moduleA\"), This rule represents the architectural requirements that a module named \"src.moduleB\" should not be imported by any module that is a submodule of \"src.moduleA\", excluding \"src.moduleA\" itself. 3) Evaluate your code against this rule rule.assert_applies(evaluable) That's it!","title":"Welcome to PyTestArch"},{"location":"#welcome-to-pytestarch","text":"PyTestArch is an open source library that allows users to define architectural rules and test their code against them. It is generally inspired by ArchUnit .","title":"Welcome to PyTestArch"},{"location":"#installation-guide","text":"PyTestArch is available via PyPI and can be installed e.g. via pip: pip install pytestarch .","title":"Installation Guide"},{"location":"#usage-guide","text":"Three steps are required to test an architectural rule: 1) Create an evaluable representation of the source code you want to test from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/dummy/project\", \"/home/dummy/project/src\") This will scan all python files under /home/dummy/project/src for imports and build an internal representation that can later be queried. The first parameter /home/dummy/project helps PyTestArch to differentiate between internal and external dependencies. This evaluable can be used for multiple architectural rule checks; if you are using pytest , you could use a fixture for this evaluable object. 2) Define an architectural rule from pytestarch.query_language.base_language import Rule rule = Rule() .modules_that() .are_named(\"src.moduleB\") .should_not() .be_imported_by_modules_that() .are_sub_modules_of(\"src.moduleA\"), This rule represents the architectural requirements that a module named \"src.moduleB\" should not be imported by any module that is a submodule of \"src.moduleA\", excluding \"src.moduleA\" itself. 3) Evaluate your code against this rule rule.assert_applies(evaluable) That's it!","title":"Usage Guide"},{"location":"changelog/","text":"Changelog This project uses semantic versioning and follows keep a changelog . [Unreleased] [1.2.1] -- 2022-10-08 Fixed Line separator for rule violation messages [1.1.1] -- 2022-10-04 Fixed Line separator for rule violation messages [1.1.0] -- 2022-10-02 Added Rule objects can be passed in as a list Fixed All violations not always returned [1.0.3] -- 2022-09-28 Changed Simplified calculation of whether imports are within the project Fixed Excluded directories no longer searched for parseable files [1.0.2] -- 2022-09-28 Fixed All internal modules filtered out if module and root path are not identical and are a sub module of the actual root module. [1.0.1] -- 2022-09-27 Fixed Module no longer considered if rule asked only for submodules of a given module [1.0.0] -- 2022-09-27 Changed Rename entry point methods for clarity Fixed Reference to outdated code in documentation [0.1.0] -- 2022-09-23 Added More detailed error message for violations of rules checking for absence of imports Versioning of documentation [0.1.0-alpha.4] -- 2022-09-23 Added Documentation for release of PyTestArch More detailed project description Changed Computation of dependencies between modules on graph [0.1.0-alpha.3] -- 2022-09-20 Fixed Different construction of graph node names between OS [0.1.0-alpha.1] -- 2022-09-20 Added Documentation library MVP","title":"Changelog"},{"location":"changelog/#changelog","text":"This project uses semantic versioning and follows keep a changelog .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#121-2022-10-08","text":"","title":"[1.2.1] -- 2022-10-08"},{"location":"changelog/#fixed","text":"Line separator for rule violation messages","title":"Fixed"},{"location":"changelog/#111-2022-10-04","text":"","title":"[1.1.1] -- 2022-10-04"},{"location":"changelog/#fixed_1","text":"Line separator for rule violation messages","title":"Fixed"},{"location":"changelog/#110-2022-10-02","text":"","title":"[1.1.0] -- 2022-10-02"},{"location":"changelog/#added","text":"Rule objects can be passed in as a list","title":"Added"},{"location":"changelog/#fixed_2","text":"All violations not always returned","title":"Fixed"},{"location":"changelog/#103-2022-09-28","text":"","title":"[1.0.3] -- 2022-09-28"},{"location":"changelog/#changed","text":"Simplified calculation of whether imports are within the project","title":"Changed"},{"location":"changelog/#fixed_3","text":"Excluded directories no longer searched for parseable files","title":"Fixed"},{"location":"changelog/#102-2022-09-28","text":"","title":"[1.0.2] -- 2022-09-28"},{"location":"changelog/#fixed_4","text":"All internal modules filtered out if module and root path are not identical and are a sub module of the actual root module.","title":"Fixed"},{"location":"changelog/#101-2022-09-27","text":"","title":"[1.0.1] -- 2022-09-27"},{"location":"changelog/#fixed_5","text":"Module no longer considered if rule asked only for submodules of a given module","title":"Fixed"},{"location":"changelog/#100-2022-09-27","text":"","title":"[1.0.0] -- 2022-09-27"},{"location":"changelog/#changed_1","text":"Rename entry point methods for clarity","title":"Changed"},{"location":"changelog/#fixed_6","text":"Reference to outdated code in documentation","title":"Fixed"},{"location":"changelog/#010-2022-09-23","text":"","title":"[0.1.0] -- 2022-09-23"},{"location":"changelog/#added_1","text":"More detailed error message for violations of rules checking for absence of imports Versioning of documentation","title":"Added"},{"location":"changelog/#010-alpha4-2022-09-23","text":"","title":"[0.1.0-alpha.4] -- 2022-09-23"},{"location":"changelog/#added_2","text":"Documentation for release of PyTestArch More detailed project description","title":"Added"},{"location":"changelog/#changed_2","text":"Computation of dependencies between modules on graph","title":"Changed"},{"location":"changelog/#010-alpha3-2022-09-20","text":"","title":"[0.1.0-alpha.3] -- 2022-09-20"},{"location":"changelog/#fixed_7","text":"Different construction of graph node names between OS","title":"Fixed"},{"location":"changelog/#010-alpha1-2022-09-20","text":"","title":"[0.1.0-alpha.1] -- 2022-09-20"},{"location":"changelog/#added_3","text":"Documentation library MVP","title":"Added"},{"location":"details/","text":"Details General Concept PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the NetworkX library. When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph. Simple Example Parsing all files Consider the following project structure: my_project/ src/ main.py util.py util_test.py Both main.py and util_test.py are importing a util function defined in util.py ; no other imports exist. With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph: Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains, \"src.main\", \"src.util\", and \"src.util_test\". In addition, a module that imports another module has a directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\". Excluding some files In the example above, the util_test.py file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude util_test.py , we could use: from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", (\"*_test.py\")) This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories. More complex example As a basis for describing the query language, let's consider a more complex example: /test_project /src __init__.py /A __init__.py fileA.py /A1 __init__.py fileA1.py fileA1_b.py /A11 __init__.py fileA11.py /A2 __init__.py fileA2.py /B __init__.py fileB.py /B1 __init__.py fileB1.py fileB2.py /C __init__.py fileC.py With the following list of imports: fileA imports fileC fileA11 imports fileB1 fileA2 imports fileC fileB imports fileA11 fileB2 imports fileA11 fileC imports the built-in os module This creates the following graph (excluding all __init__.py ): Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\". Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all. This has been achieved by setting the exclude_external_libraries flag in the get_evaluable_architecture function. All modules that not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph. Query Language General Structure The query language that can be used to define architectural rules follows this structure: RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT The meaning of these structural markers is described in the table below. Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except The examples given in the table above combined form the rule modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT) . Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing from the \"B\" module is \"fileA11\", which is a submodule of \"A\". Features Currently, the following markers are supported by PyTestArch: RULE_SUBJECT are_named(\"X\"): applies to module named \"X\" (and also to its submodules) are_submodules_of(\"Y\"): applies to submodules of module named \"Y\", but not \"Y\" itself RULE_OBJECT same as RULE_SUBJECT, with an additional anything(): can only be used in combination with should_not() In addition, RULE_OBJECTS can be passed in as a list. The rule is fulfilled if it applies to all rule objects. For example, the rule modules_that() .are_named(\"1\") .should_only() .be_imported_by_modules_that() .are_named([\"2\", \"3\"]) is fulfilled, it the module \"1\" is not imported by any module other than \"2\" and \"3\", and if both \"2\" and \"3\" do import \"1\". VERB_MARKER_1 should() should_only() should_not() IMPORT_TYPE + VERB_MARKER_2 import_modules_that() import_modules_except_modules_that() be_imported_by_modules_that() be_imported_by_modules_except_modules_that() VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability. Markers from each category can be combined freely with all markers of all other categories. Example rules could be modules_that() .are_sub_modules_of(\"A\") .should_only() .be_imported_by_modules_that() .are_sub_modules_of(\"B\") (True in the above example) or modules_that() .are_named(\"C\") .should_only() .be_imported_by_modules_that() .are_named(\"A2\") (False, also imported by module \"A\") Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo-code for brevity): Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1 There are two aliases to make rules easier: 'M1 should not import anything' is equivalent to: 'M1 should not import anything except itself' (e.g. imports between its submodules are allowed, but no other imports) 'M1 should not be imported by anything' is equivalent to: 'M1 should not be imported by anything except itself' (dito) Generating the evaluable architecture representation When scanning and processing the requested modules, PyTestArch executes the following step: 1) Parse all files starting at the requested module_path . This only takes python source files into account that are not explicitly excluded. 2) Convert the generated AST into custom dependency representations. In this step, it is ensured that all internal modules (either importing or imported) receive their fully qualified name. 3) Generate a list of all modules that were parsed. This list is used to differentiate between external and internal dependencies (external dependencies will not have been parsed). 4) If not requested otherwise, external dependencies will be filtered out. 5) If external dependencies should be included, they will be added to the list of modules. 6) The dependency representations are converted to a graph structure. Additional Notes root_path vs. module_path in get_evaluable_architecture The root_path should point towards the most top level module. In the example above, this would be src - not test_project , as test_project is not the top level code directory. The module_path is the module where the dependency scan will start. It has to be either identical to root_path or a submodule of it. Module names In all rules, modules have to be referred to by their fully qualified name, meaning relative to the root_path - not the module_path ! This helps to distinguish between internal and external modules.","title":"Details"},{"location":"details/#details","text":"","title":"Details"},{"location":"details/#general-concept","text":"PyTestArch creates an Abstract Syntax Tree for each Python file it scans. It then extracts only the information about module imports from the AST and converts them to an internal representation. This is currently a graph supplied by the NetworkX library. When the user defines a rule and evaluates the internal representation against it, the rule is converted into a set of graph operations that are then carried out on the previously generated graph.","title":"General Concept"},{"location":"details/#simple-example","text":"","title":"Simple Example"},{"location":"details/#parsing-all-files","text":"Consider the following project structure: my_project/ src/ main.py util.py util_test.py Both main.py and util_test.py are importing a util function defined in util.py ; no other imports exist. With \"my_project\" as the project's root folder and \"src\" as the folder to evaluate, this will create the following graph: Each module has a direct path to all submodules, in this case: \"src\" is connected to all three modules it contains, \"src.main\", \"src.util\", and \"src.util_test\". In addition, a module that imports another module has a directed edge linking it to this module. For example, \"src.main\" imports \"src.util\" and therefore the graph has an edge connecting these modules, with the arrow head pointing at the imported module, in this case \"src.util\".","title":"Parsing all files"},{"location":"details/#excluding-some-files","text":"In the example above, the util_test.py file is included in the graph and will be considered when evaluating the architecture. If certain files should be excluded from the analysis, this can be done by specifying an exclusion pattern. In our example, if we want to exclude util_test.py , we could use: from pytestarch.pytestarch import get_evaluable_architecture evaluable = get_evaluable_architecture(\"/home/my_project\", \"/home/my_project/src\", (\"*_test.py\")) This will exclude all files with names ending in \"_test.py\". It is also possible to exclude directories.","title":"Excluding some files"},{"location":"details/#more-complex-example","text":"As a basis for describing the query language, let's consider a more complex example: /test_project /src __init__.py /A __init__.py fileA.py /A1 __init__.py fileA1.py fileA1_b.py /A11 __init__.py fileA11.py /A2 __init__.py fileA2.py /B __init__.py fileB.py /B1 __init__.py fileB1.py fileB2.py /C __init__.py fileC.py With the following list of imports: fileA imports fileC fileA11 imports fileB1 fileA2 imports fileC fileB imports fileA11 fileB2 imports fileA11 fileC imports the built-in os module This creates the following graph (excluding all __init__.py ): Note that the module names in the diagram have been abbreviated: For example, the node \"fileA\" is actually named \"src.A.fileA\". Most of the edges in this graph are due to parent-child relationships between the modules. However, five of the six import relationships defined above are present in the graph - only fileC has no connection to an \"os\" node; in fact, there is no node names \"os\" at all. This has been achieved by setting the exclude_external_libraries flag in the get_evaluable_architecture function. All modules that not located hierarchically below the root path, in this case \"test_project\", will be excluded from the graph.","title":"More complex example"},{"location":"details/#query-language","text":"","title":"Query Language"},{"location":"details/#general-structure","text":"The query language that can be used to define architectural rules follows this structure: RULE_SUBJECT - VERB_MARKER_1 - IMPORT_TYPE - VERB_MARKER_2 - RULE_OBJECT The meaning of these structural markers is described in the table below. Marker Description Example RULE_SUBJECT module(s) to be checked modules that are named 'B' RULE_OBJECT module(s) to check against modules that are submodules of 'A' IMPORT_TYPE expected type of import relationship be imported by VERB_MARKER_1 defines the expected behavior, part I should not VERB_MARKER_2 defines the expected behavior, part II except The examples given in the table above combined form the rule modules that are named 'B' (RULE_SUBJECT) should not (VERB_MARKER_1) be imported by (IMPORT_TYPE) modules except (VERB_MARKER_2) modules that are submodules of \"A\" (RULE_OBJECT) . Looking at the diagram in the section Complex Example, we can see that this rule holds - the only module importing from the \"B\" module is \"fileA11\", which is a submodule of \"A\".","title":"General Structure"},{"location":"details/#features","text":"Currently, the following markers are supported by PyTestArch:","title":"Features"},{"location":"details/#rule_subject","text":"are_named(\"X\"): applies to module named \"X\" (and also to its submodules) are_submodules_of(\"Y\"): applies to submodules of module named \"Y\", but not \"Y\" itself","title":"RULE_SUBJECT"},{"location":"details/#rule_object","text":"same as RULE_SUBJECT, with an additional anything(): can only be used in combination with should_not() In addition, RULE_OBJECTS can be passed in as a list. The rule is fulfilled if it applies to all rule objects. For example, the rule modules_that() .are_named(\"1\") .should_only() .be_imported_by_modules_that() .are_named([\"2\", \"3\"]) is fulfilled, it the module \"1\" is not imported by any module other than \"2\" and \"3\", and if both \"2\" and \"3\" do import \"1\".","title":"RULE_OBJECT"},{"location":"details/#verb_marker_1","text":"should() should_only() should_not()","title":"VERB_MARKER_1"},{"location":"details/#import_type-verb_marker_2","text":"import_modules_that() import_modules_except_modules_that() be_imported_by_modules_that() be_imported_by_modules_except_modules_that() VERB_MARKER_2 and IMPORT_TYPE have been conflated into one expression to improve readability. Markers from each category can be combined freely with all markers of all other categories. Example rules could be modules_that() .are_sub_modules_of(\"A\") .should_only() .be_imported_by_modules_that() .are_sub_modules_of(\"B\") (True in the above example) or modules_that() .are_named(\"C\") .should_only() .be_imported_by_modules_that() .are_named(\"A2\") (False, also imported by module \"A\") Most rules are so close to the English language that a detailed explanation seems unnecessary. An exception might be the VERB_MARKER_2 \"except\". A combination of this VERB_MARKER_2 and every type of VERB_MARKER_1 and IMPORT_TYPE is given below as reference (M1, M2 are used as RULE_SUBJECT and RULE_OBJECT respectively; pseudo-code for brevity): Rule Explanation M1 should import except M2 M1 should import at least one module that isn't M2, but can also import M2 M1 should only import except M2 M1 should import at least one module that isn't M2 and should not import M2 M1 should not import except M2 M1 should not import any module other than M2, but does not have to import M2 M1 should be imported except by M2 at least one module that isn't M2 should import M1 (M2 can import M1 as well) M1 should only be imported except by M2 at least one module that isn't M2 should import M1, and M2 cannot import M1 M1 should not be imported except by M2 no module other than M2 should import M1, but M2 does not have to import M1 There are two aliases to make rules easier: 'M1 should not import anything' is equivalent to: 'M1 should not import anything except itself' (e.g. imports between its submodules are allowed, but no other imports) 'M1 should not be imported by anything' is equivalent to: 'M1 should not be imported by anything except itself' (dito)","title":"IMPORT_TYPE + VERB_MARKER_2"},{"location":"details/#generating-the-evaluable-architecture-representation","text":"When scanning and processing the requested modules, PyTestArch executes the following step: 1) Parse all files starting at the requested module_path . This only takes python source files into account that are not explicitly excluded. 2) Convert the generated AST into custom dependency representations. In this step, it is ensured that all internal modules (either importing or imported) receive their fully qualified name. 3) Generate a list of all modules that were parsed. This list is used to differentiate between external and internal dependencies (external dependencies will not have been parsed). 4) If not requested otherwise, external dependencies will be filtered out. 5) If external dependencies should be included, they will be added to the list of modules. 6) The dependency representations are converted to a graph structure.","title":"Generating the evaluable architecture representation"},{"location":"details/#additional-notes","text":"","title":"Additional Notes"},{"location":"details/#root_path-vs-module_path-in-get_evaluable_architecture","text":"The root_path should point towards the most top level module. In the example above, this would be src - not test_project , as test_project is not the top level code directory. The module_path is the module where the dependency scan will start. It has to be either identical to root_path or a submodule of it.","title":"root_path vs. module_path in get_evaluable_architecture"},{"location":"details/#module-names","text":"In all rules, modules have to be referred to by their fully qualified name, meaning relative to the root_path - not the module_path ! This helps to distinguish between internal and external modules.","title":"Module names"},{"location":"eval_structure/","text":"Evaluation eval_structure This model contains abstract types as well as their implementations to represent the imported dependencies in a queryable structure, such as graphs. evaluable_architecture Abstract types to specify the interface of evaluable objects. EvaluableArchitecture Bases: Protocol any_dependencies_to_modules_other_than ( dependents , dependent_upons ) Returns list of depending modules per dependent module if the dependent module has any dependency to a module other than the dependent_upon modules or any of their submodules. If a dependent module is defined via a parent module, this parent module is not taken into account. If a dependent upon module is defined via a parent module, this parent module counts as an 'other' dependency. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description LaxDependenciesByBaseModule All modules other than dependent_upon on which dependent module as any dependency per dependent module any_other_dependencies_to_modules_than ( dependents , dependent_upons ) Returns list of depending modules per dependent_upon module if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. If the dependent module is defined via a parent module, this parent module is taken into account. This means that if the dependent module's parent module has a dependency to the dependent upon module, this will be contained in the returned list. If the dependent upon module is defined via a parent module, this parent module is not taken into account. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description LaxDependenciesByBaseModule All modules other than dependent that have any dependency on the dependent upon module per dependent_upon module get_dependencies ( dependents , dependent_upons ) Returns tuple of importer and importee per dependent and depending module if the dependent module is indeed depending on the dependent_upon module. Submodules of dependent towards are taken into account, but submodules of dependent_upon are not. If one or both of the modules are defined by their parent module, this parent module is excluded from possible matches. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description StrictDependenciesByBaseModules Importer and importee per pair of dependent and dependent_upon module if there are any that are sub modules of dependent and dependent_upon respectively. visualize ( ** kwargs ) Uses matplotlib to draw the underlying dependency structure. Parameters: Name Type Description Default **kwargs Any Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout). {} Module dataclass Represents a python module. The module can either be identified by its name or by the name of a parent module. Attributes: Name Type Description name Optional [ str ] full name of the module parent_module Optional [ str ] full name of the parent module evaluable_structures evaluable_graph Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern. EvaluableArchitectureGraph Bases: EvaluableArchitecture Abstract implementation of an evaluable object that is based on a graph structure. networkxgraph Encapsulation of networkx graph functionality. NetworkxGraph Bases: AbstractGraph Constructs eval_structure from list of imports. Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy. E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')] __init__ ( all_modules , imports , level_limit = None ) Parameters: Name Type Description Default all_modules List [ Node ] list of all nodes in the graph, which can be connected by imports. required imports List [ Import ] all dependencies between the graph's nodes. required level_limit Optional [ int ] if not None, specifies the depth of the graph None direct_predecessor_nodes ( node ) Returns all nodes that have a directed edge towards the given node. Parameters: Name Type Description Default node Node node for which to retrieve predecessor nodes required Returns: Type Description List [ Node ] all predecessor nodes direct_successor_nodes ( node ) Returns all nodes that the given node has a directed edge towards. Parameters: Name Type Description Default node Node node for which to retrieve successor nodes required Returns: Type Description List [ Node ] all successor nodes draw ( ** kwargs ) Creates a matplotlib plot representing the graph. parent_child_relationship ( supposed_parent_node , supposed_child_node ) Returns True if the given nodes are marked as a parent-child hierarchy. Parameters: Name Type Description Default supposed_parent_node Node required supposed_child_node Node required Returns: Type Description bool True if supposed parent is actually parent of supposed child node","title":"Evaluation"},{"location":"eval_structure/#evaluation","text":"","title":"Evaluation"},{"location":"eval_structure/#src.pytestarch.eval_structure","text":"This model contains abstract types as well as their implementations to represent the imported dependencies in a queryable structure, such as graphs.","title":"eval_structure"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture","text":"Abstract types to specify the interface of evaluable objects.","title":"evaluable_architecture"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture","text":"Bases: Protocol","title":"EvaluableArchitecture"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_dependencies_to_modules_other_than","text":"Returns list of depending modules per dependent module if the dependent module has any dependency to a module other than the dependent_upon modules or any of their submodules. If a dependent module is defined via a parent module, this parent module is not taken into account. If a dependent upon module is defined via a parent module, this parent module counts as an 'other' dependency. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description LaxDependenciesByBaseModule All modules other than dependent_upon on which dependent module as any dependency per dependent module","title":"any_dependencies_to_modules_other_than()"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.any_other_dependencies_to_modules_than","text":"Returns list of depending modules per dependent_upon module if any module other than the dependent module and its submodules has any dependency to the dependent_upon module. If the dependent module is defined via a parent module, this parent module is taken into account. This means that if the dependent module's parent module has a dependency to the dependent upon module, this will be contained in the returned list. If the dependent upon module is defined via a parent module, this parent module is not taken into account. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description LaxDependenciesByBaseModule All modules other than dependent that have any dependency on the dependent upon module per dependent_upon module","title":"any_other_dependencies_to_modules_than()"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.get_dependencies","text":"Returns tuple of importer and importee per dependent and depending module if the dependent module is indeed depending on the dependent_upon module. Submodules of dependent towards are taken into account, but submodules of dependent_upon are not. If one or both of the modules are defined by their parent module, this parent module is excluded from possible matches. Parameters: Name Type Description Default dependent Module required dependent_upon Module required Returns: Type Description StrictDependenciesByBaseModules Importer and importee per pair of dependent and dependent_upon module if there are any that are sub modules of dependent and dependent_upon respectively.","title":"get_dependencies()"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.EvaluableArchitecture.visualize","text":"Uses matplotlib to draw the underlying dependency structure. Parameters: Name Type Description Default **kwargs Any Any formatting options available for networkx' drawing function, as this is currently the only available backend. Exception: If 'spacing' is set, this will be interpreted as the parameter 'k' of the spring layout (https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html#networkx.drawing.layout.spring_layout). {}","title":"visualize()"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_architecture.Module","text":"Represents a python module. The module can either be identified by its name or by the name of a parent module. Attributes: Name Type Description name Optional [ str ] full name of the module parent_module Optional [ str ] full name of the parent module","title":"Module"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_structures","text":"","title":"evaluable_structures"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_graph","text":"Base class for different graph implementations of an evaluable structure. Delegates direct access to graph nodes and edges to its subclasses in a template pattern.","title":"evaluable_graph"},{"location":"eval_structure/#src.pytestarch.eval_structure.evaluable_graph.EvaluableArchitectureGraph","text":"Bases: EvaluableArchitecture Abstract implementation of an evaluable object that is based on a graph structure.","title":"EvaluableArchitectureGraph"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph","text":"Encapsulation of networkx graph functionality.","title":"networkxgraph"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph","text":"Bases: AbstractGraph Constructs eval_structure from list of imports. Each module passed to this object will be added as a node. Importing and imported module are connected via a direct edge. Edges are added between each successive level in the module hierarchy. E.g. Import('A.B', 'C.D.E') results in - nodes: ['A', 'A.B', 'C', 'C.D', 'C.D.E'] - edges: [('A', 'A.B'), ('C', 'C.D'), ('C.D', 'C.D.E'), ('A.B', 'C.D.E')]","title":"NetworkxGraph"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph.__init__","text":"Parameters: Name Type Description Default all_modules List [ Node ] list of all nodes in the graph, which can be connected by imports. required imports List [ Import ] all dependencies between the graph's nodes. required level_limit Optional [ int ] if not None, specifies the depth of the graph None","title":"__init__()"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph.direct_predecessor_nodes","text":"Returns all nodes that have a directed edge towards the given node. Parameters: Name Type Description Default node Node node for which to retrieve predecessor nodes required Returns: Type Description List [ Node ] all predecessor nodes","title":"direct_predecessor_nodes()"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph.direct_successor_nodes","text":"Returns all nodes that the given node has a directed edge towards. Parameters: Name Type Description Default node Node node for which to retrieve successor nodes required Returns: Type Description List [ Node ] all successor nodes","title":"direct_successor_nodes()"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph.draw","text":"Creates a matplotlib plot representing the graph.","title":"draw()"},{"location":"eval_structure/#src.pytestarch.eval_structure_impl.networkxgraph.NetworkxGraph.parent_child_relationship","text":"Returns True if the given nodes are marked as a parent-child hierarchy. Parameters: Name Type Description Default supposed_parent_node Node required supposed_child_node Node required Returns: Type Description bool True if supposed parent is actually parent of supposed child node","title":"parent_child_relationship()"},{"location":"general/","text":"General pytestarch The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules. get_evaluable_architecture ( root_path , module_path , exclusions = DEFAULT_EXCLUSIONS , exclude_external_libraries = True , level_limit = None ) Constructs an evaluable object based on the given module. Parameters: Name Type Description Default root_path str root directory of the source code. Should not be set to a submodule of the top level module. required module_path str path of module to generate the evaluable for. Must be a submodule of the root_path module. required exclusions Tuple [ str , ...] pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py DEFAULT_EXCLUSIONS exclude_external_libraries bool if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis. True level_limit Optional [ int ] if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit. None get_evaluable_architecture_for_module_objects ( root_module , module , exclusions = DEFAULT_EXCLUSIONS , exclude_external_libraries = True , level_limit = None ) Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.","title":"General"},{"location":"general/#general","text":"","title":"General"},{"location":"general/#src.pytestarch.pytestarch","text":"The following two functions are the main entry point to PyTestArch. They can be used to create an evaluable object, for which the user can then define architectural rules.","title":"pytestarch"},{"location":"general/#src.pytestarch.pytestarch.get_evaluable_architecture","text":"Constructs an evaluable object based on the given module. Parameters: Name Type Description Default root_path str root directory of the source code. Should not be set to a submodule of the top level module. required module_path str path of module to generate the evaluable for. Must be a submodule of the root_path module. required exclusions Tuple [ str , ...] pseudo-regex to exclude files and directories from being integrated into the evaluable, e.g. *Test.py DEFAULT_EXCLUSIONS exclude_external_libraries bool if True, external dependencies (defined as all dependencies to module outside the module_path, including Python built-in modules) will not be taken into account for the dependency analysis. True level_limit Optional [ int ] if not None, specifies the depth of the graph. For example, a limit of 1 will result in only the modules one level below the module path to be added as nodes. Note that this only applies to the final graph; all modules will be parsed, the graph will simply be flattened: if a submodule of X imports Y, this import is then assigned to X instead, if Y is above the level limit. None","title":"get_evaluable_architecture()"},{"location":"general/#src.pytestarch.pytestarch.get_evaluable_architecture_for_module_objects","text":"Same functionality as get_evaluable_architecture, but root module and module to evaluate are passed in as module objects instead of the absolute paths to them.","title":"get_evaluable_architecture_for_module_objects()"},{"location":"parsing/","text":"Parsing converter ImportConverter Converts all ast imports to custom import types. convert ( asts ) Converts ast modules to custom import modules. Filters out all modules that are not imports. Parameters: Name Type Description Default asts List [ NamedModule ] list of ast modules required Returns: Type Description List [ Import ] list of import objects file_filter FileFilter Uses a pseudo-regex pattern to determine whether a file or directory should be excluded. Allowed patterns are: - A : file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A : file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A' is_excluded ( path ) Returns True if the path matches one of the pre-configured exclusion patterns. import_filter ImportFilter Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports. __init__ ( exclude_external_libraries , root_module_name ) Parameters: Name Type Description Default exclude_external_libraries bool If True, external modules will be filtered out, otherwise this class implements a no-op. required root_module_name str name of the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal. required filter ( imports ) According to the configuration, imports will be filtered. Parameters: Name Type Description Default imports List [ Import ] list of imports to be filtered required Returns: Type Description List [ Import ] filtered list of imports import_types AbsoluteImport Bases: Import Represents an absolute import. Import Bases: ABC importee () abstractmethod Returns name of a module that is being imported. Returns: Type Description str module name importee_parent_modules () abstractmethod Returns names of all parent modules of the imported module. Returns: Type Description List [ str ] list of module names importer () Returns name of the module that imports something. Returns: Type Description str module name importer_parent_modules () Returns names of all parent modules of the importing module. Returns: Type Description List [ str ] list of module names NamedModule dataclass Contains an ast module with its name. Attributes: Name Type Description module ast . Module ast module object name str module name RelativeImport Bases: Import Represents a relative import. importee_module_calculator ImporteeModuleCalculator Adds all parent modules of imported modules if they are not yet part of the modules list. calculate_importee_modules ( imports , all_modules ) For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies. Parameters: Name Type Description Default imports List [ Import ] required all_modules List [ str ] required Returns: Type Description List [ str ] all modules extended by parent modules of imported modules parser Parser Parses all files that match given criteria starting at a source path. parse ( path ) Reads all python files in the given path and returns list of ast modules with names. Parameters: Name Type Description Default path Path either to a file or to a directory required Returns: Type Description Tuple [ List [ str ], List [ NamedModule ]] list of python modules, one per python file","title":"Parsing"},{"location":"parsing/#parsing","text":"","title":"Parsing"},{"location":"parsing/#src.pytestarch.importer.converter","text":"","title":"converter"},{"location":"parsing/#src.pytestarch.importer.converter.ImportConverter","text":"Converts all ast imports to custom import types.","title":"ImportConverter"},{"location":"parsing/#src.pytestarch.importer.converter.ImportConverter.convert","text":"Converts ast modules to custom import modules. Filters out all modules that are not imports. Parameters: Name Type Description Default asts List [ NamedModule ] list of ast modules required Returns: Type Description List [ Import ] list of import objects","title":"convert()"},{"location":"parsing/#src.pytestarch.importer.file_filter","text":"","title":"file_filter"},{"location":"parsing/#src.pytestarch.importer.file_filter.FileFilter","text":"Uses a pseudo-regex pattern to determine whether a file or directory should be excluded. Allowed patterns are: - A : file or dir will be excluded, if 'A' is part of their name - A: file or dir will be excluded, if their name ends with 'A' - A : file or dir will be excluded, if their name starts with 'A' - A: file or dir will be excluded, if their name is 'A'","title":"FileFilter"},{"location":"parsing/#src.pytestarch.importer.file_filter.FileFilter.is_excluded","text":"Returns True if the path matches one of the pre-configured exclusion patterns.","title":"is_excluded()"},{"location":"parsing/#src.pytestarch.importer.import_filter","text":"","title":"import_filter"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter","text":"Filters out imports of external modules from the list of all imports. External modules are all modules that are not submodules of the configured module to search for imports.","title":"ImportFilter"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter.__init__","text":"Parameters: Name Type Description Default exclude_external_libraries bool If True, external modules will be filtered out, otherwise this class implements a no-op. required root_module_name str name of the module that determines which modules are considered external. If a module is a submodule of this module, it is considered internal. required","title":"__init__()"},{"location":"parsing/#src.pytestarch.importer.import_filter.ImportFilter.filter","text":"According to the configuration, imports will be filtered. Parameters: Name Type Description Default imports List [ Import ] list of imports to be filtered required Returns: Type Description List [ Import ] filtered list of imports","title":"filter()"},{"location":"parsing/#src.pytestarch.importer.import_types","text":"","title":"import_types"},{"location":"parsing/#src.pytestarch.importer.import_types.AbsoluteImport","text":"Bases: Import Represents an absolute import.","title":"AbsoluteImport"},{"location":"parsing/#src.pytestarch.importer.import_types.Import","text":"Bases: ABC","title":"Import"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importee","text":"Returns name of a module that is being imported. Returns: Type Description str module name","title":"importee()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importee_parent_modules","text":"Returns names of all parent modules of the imported module. Returns: Type Description List [ str ] list of module names","title":"importee_parent_modules()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importer","text":"Returns name of the module that imports something. Returns: Type Description str module name","title":"importer()"},{"location":"parsing/#src.pytestarch.importer.import_types.Import.importer_parent_modules","text":"Returns names of all parent modules of the importing module. Returns: Type Description List [ str ] list of module names","title":"importer_parent_modules()"},{"location":"parsing/#src.pytestarch.importer.import_types.NamedModule","text":"Contains an ast module with its name. Attributes: Name Type Description module ast . Module ast module object name str module name","title":"NamedModule"},{"location":"parsing/#src.pytestarch.importer.import_types.RelativeImport","text":"Bases: Import Represents a relative import.","title":"RelativeImport"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator","text":"","title":"importee_module_calculator"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator.ImporteeModuleCalculator","text":"Adds all parent modules of imported modules if they are not yet part of the modules list.","title":"ImporteeModuleCalculator"},{"location":"parsing/#src.pytestarch.importer.importee_module_calculator.ImporteeModuleCalculator.calculate_importee_modules","text":"For all imported modules: Calculate parent modules and add them to the list of existing modules if they are not already part of this list. This mainly applies to external dependencies. Parameters: Name Type Description Default imports List [ Import ] required all_modules List [ str ] required Returns: Type Description List [ str ] all modules extended by parent modules of imported modules","title":"calculate_importee_modules()"},{"location":"parsing/#src.pytestarch.importer.parser","text":"","title":"parser"},{"location":"parsing/#src.pytestarch.importer.parser.Parser","text":"Parses all files that match given criteria starting at a source path.","title":"Parser"},{"location":"parsing/#src.pytestarch.importer.parser.Parser.parse","text":"Reads all python files in the given path and returns list of ast modules with names. Parameters: Name Type Description Default path Path either to a file or to a directory required Returns: Type Description Tuple [ List [ str ], List [ NamedModule ]] list of python modules, one per python file","title":"parse()"},{"location":"query_language/","text":"Query Language base_language BehaviorSpecification Bases: ABC Offers functionality to specify whether dependencies are expected or not. DependencySpecification Bases: ABC Offers functionality to specify which kind of dependencies are expected. ModuleSpecification Bases: Generic [ ModuleSpecificationSuccessor ] , ABC Offers functionality to specify detail information about Rule Subjects or Objects. Rule Bases: DependencySpecification , RuleBase , BehaviorSpecification , RuleObject , RuleSubject , RuleApplier Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2 RuleApplier Bases: ABC assert_applies ( evaluable ) abstractmethod Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents. Parameters: Name Type Description Default evaluable EvaluableArchitecture module dependency structure to compare the rule against required Raises: Type Description AssertionError if the rule does not apply to the evaluable object RuleBase Bases: ABC Entry point to each architectural rule. rule_matcher BehaviorRequirement Stores information about which import behavior the checked module is supposed to exhibit. generate_rule_violation ( strict_dependencies , lax_dependencies , import_rule , left_hand_side_module , right_hand_side_module ) Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them. Parameters: Name Type Description Default strict_dependencies Optional [ StrictDependenciesByBaseModules ] dependency between the two specified modules found, grouped by requested modules required lax_dependencies Optional [ LaxDependenciesByBaseModule ] other dependencies found beside the two specified modules required Returns: Type Description RuleViolations overview of all rule violations lax_dependency_not_allowed () property Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement. lax_dependency_required () property Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement. strict_dependency_not_allowed () property Returns True if a dependency between two specific modules is not allowed. strict_dependency_required () property Returns True if a dependency between two specific modules is required. ModuleRequirement Stores information about which module is supposed to be checked against which module. RuleMatcher Bases: ABC Checks whether given modules fulfill the module and behavior requirements that have been specified for them. match ( evaluable ) abstractmethod Checks whether an expected behavior is exhibited by the EvaluableArchitecture. Parameters: Name Type Description Default evaluable EvaluableArchitecture object to check required Returns: Type Description RuleViolations overview of rule violations message_generator Converts a RuleViolations object into a human-readable format. RuleViolationMessageGenerator Generates a message for each violated rule. __init__ ( original_rule_subject , original_rule_objects , import_rule ) Parameters: Name Type Description Default original_rule_subject Module module as originally specified required original_rule_objects List [ Module ] modules as originally specified required import_rule bool True if the underlying rule is a \"import\" instead of an \"is imported\" rule required create_rule_violation_messages ( rule_violations ) Create a message about each rule violation. Parameters: Name Type Description Default rule_violations RuleViolations to convert to human-readable format required Returns: Type Description List [ str ] set of messages, each representing a rule violation","title":"Query Language"},{"location":"query_language/#query-language","text":"","title":"Query Language"},{"location":"query_language/#src.pytestarch.query_language.base_language","text":"","title":"base_language"},{"location":"query_language/#src.pytestarch.query_language.base_language.BehaviorSpecification","text":"Bases: ABC Offers functionality to specify whether dependencies are expected or not.","title":"BehaviorSpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.DependencySpecification","text":"Bases: ABC Offers functionality to specify which kind of dependencies are expected.","title":"DependencySpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.ModuleSpecification","text":"Bases: Generic [ ModuleSpecificationSuccessor ] , ABC Offers functionality to specify detail information about Rule Subjects or Objects.","title":"ModuleSpecification"},{"location":"query_language/#src.pytestarch.query_language.base_language.Rule","text":"Bases: DependencySpecification , RuleBase , BehaviorSpecification , RuleObject , RuleSubject , RuleApplier Represents an architectural rule of the form Module1 [verb, such as 'should'] [import type, such as 'import'] Module2","title":"Rule"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleApplier","text":"Bases: ABC","title":"RuleApplier"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleApplier.assert_applies","text":"Calculates whether it (the rule) applies to a given EvaluableArchitecture. This means calculating which behavior is wanted and then checking this to the state the Evaluable represents. Parameters: Name Type Description Default evaluable EvaluableArchitecture module dependency structure to compare the rule against required Raises: Type Description AssertionError if the rule does not apply to the evaluable object","title":"assert_applies()"},{"location":"query_language/#src.pytestarch.query_language.base_language.RuleBase","text":"Bases: ABC Entry point to each architectural rule.","title":"RuleBase"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher","text":"","title":"rule_matcher"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement","text":"Stores information about which import behavior the checked module is supposed to exhibit.","title":"BehaviorRequirement"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.generate_rule_violation","text":"Translate from the detected types of dependencies back to which behavior and dependency requirements are violated by them. Parameters: Name Type Description Default strict_dependencies Optional [ StrictDependenciesByBaseModules ] dependency between the two specified modules found, grouped by requested modules required lax_dependencies Optional [ LaxDependenciesByBaseModule ] other dependencies found beside the two specified modules required Returns: Type Description RuleViolations overview of all rule violations","title":"generate_rule_violation()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.lax_dependency_not_allowed","text":"Returns True if no dependency between a specific module and a set of other modules is not allowed. Which other modules are not allowed is specified by the module requirement.","title":"lax_dependency_not_allowed()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.lax_dependency_required","text":"Returns True if a dependency between a specific module and any other modules is required. Which other modules are required is specified by the module requirement.","title":"lax_dependency_required()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.strict_dependency_not_allowed","text":"Returns True if a dependency between two specific modules is not allowed.","title":"strict_dependency_not_allowed()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.BehaviorRequirement.strict_dependency_required","text":"Returns True if a dependency between two specific modules is required.","title":"strict_dependency_required()"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.ModuleRequirement","text":"Stores information about which module is supposed to be checked against which module.","title":"ModuleRequirement"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.RuleMatcher","text":"Bases: ABC Checks whether given modules fulfill the module and behavior requirements that have been specified for them.","title":"RuleMatcher"},{"location":"query_language/#src.pytestarch.query_language.rule_matcher.RuleMatcher.match","text":"Checks whether an expected behavior is exhibited by the EvaluableArchitecture. Parameters: Name Type Description Default evaluable EvaluableArchitecture object to check required Returns: Type Description RuleViolations overview of rule violations","title":"match()"},{"location":"query_language/#src.pytestarch.query_language.message_generator","text":"Converts a RuleViolations object into a human-readable format.","title":"message_generator"},{"location":"query_language/#src.pytestarch.query_language.message_generator.RuleViolationMessageGenerator","text":"Generates a message for each violated rule.","title":"RuleViolationMessageGenerator"},{"location":"query_language/#src.pytestarch.query_language.message_generator.RuleViolationMessageGenerator.__init__","text":"Parameters: Name Type Description Default original_rule_subject Module module as originally specified required original_rule_objects List [ Module ] modules as originally specified required import_rule bool True if the underlying rule is a \"import\" instead of an \"is imported\" rule required","title":"__init__()"},{"location":"query_language/#src.pytestarch.query_language.message_generator.RuleViolationMessageGenerator.create_rule_violation_messages","text":"Create a message about each rule violation. Parameters: Name Type Description Default rule_violations RuleViolations to convert to human-readable format required Returns: Type Description List [ str ] set of messages, each representing a rule violation","title":"create_rule_violation_messages()"}]}